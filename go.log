SCRIPT  /Users/ryan/.vim/bundle/vim-go/syntax/go.vim
Sourced 1 time
Total time:   0.002459
 Self time:   0.001988

count  total (s)   self (s)
                            " Copyright 2009 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " go.vim: Vim syntax file for Go.
                            
                            " Quit when a (custom) syntax file was already loaded
    1              0.000005 if exists("b:current_syntax")
                              finish
    1              0.000000 endif
                            
    1              0.000001 syn case match
                            
    1              0.000013 syn keyword     goPackage           package
    1              0.000004 syn keyword     goImport            import    contained
    1              0.000003 syn keyword     goVar               var       contained
    1              0.000002 syn keyword     goConst             const     contained
                            
    1              0.000009 hi def link     goPackage           Statement
    1              0.000004 hi def link     goImport            Statement
    1              0.000004 hi def link     goVar               Keyword
    1              0.000004 hi def link     goConst             Keyword
    1              0.000004 hi def link     goDeclaration       Keyword
                            
                            " Keywords within functions
    1              0.000005 syn keyword     goStatement         defer go goto return break continue fallthrough
    1              0.000003 syn keyword     goConditional       if else switch select
    1              0.000002 syn keyword     goLabel             case default
    1              0.000003 syn keyword     goRepeat            for range
                            
    1              0.000004 hi def link     goStatement         Statement
    1              0.000004 hi def link     goConditional       Conditional
    1              0.000004 hi def link     goLabel             Label
    1              0.000004 hi def link     goRepeat            Repeat
                            
                            " Predefined types
    1              0.000005 syn keyword     goType              chan map bool string error any comparable
    1              0.000003 syn keyword     goSignedInts        int int8 int16 int32 int64 rune
    1              0.000004 syn keyword     goUnsignedInts      byte uint uint8 uint16 uint32 uint64 uintptr
    1              0.000002 syn keyword     goFloats            float32 float64
    1              0.000004 syn keyword     goComplexes         complex64 complex128
                            
    1              0.000004 hi def link     goType              Type
    1              0.000004 hi def link     goSignedInts        Type
    1              0.000004 hi def link     goUnsignedInts      Type
    1              0.000004 hi def link     goFloats            Type
    1              0.000004 hi def link     goComplexes         Type
                            
                            " Predefined functions and values
    1              0.000010 syn keyword     goBuiltins                 append cap close complex copy delete imag len
    1              0.000004 syn keyword     goBuiltins                 make new panic print println real recover
    1              0.000002 syn keyword     goBoolean                  true false
    1              0.000003 syn keyword     goPredefinedIdentifiers    nil iota
                            
    1              0.000004 hi def link     goBuiltins                 Identifier
    1              0.000004 hi def link     goBoolean                  Boolean
    1              0.000004 hi def link     goPredefinedIdentifiers    goBoolean
                            
                            " Comments; their contents
    1              0.000004 syn keyword     goTodo              contained TODO FIXME XXX BUG
    1              0.000005 syn cluster     goCommentGroup      contains=goTodo
                            
    1              0.000012 syn region      goComment           start="//" end="$" contains=goGenerate,@goCommentGroup,@Spell
    1   0.000031   0.000010 if go#config#FoldEnable('comment')
                              syn region    goComment           start="/\*" end="\*/" contains=@goCommentGroup,@Spell fold
                              syn match     goComment           "\v(^\s*//.*\n)+" contains=goGenerate,@goCommentGroup,@Spell fold
    1              0.000001 else
    1              0.000007   syn region    goComment           start="/\*" end="\*/" contains=@goCommentGroup,@Spell
    1              0.000001 endif
                            
    1              0.000004 hi def link     goComment           Comment
    1              0.000004 hi def link     goTodo              Todo
                            
    1   0.000011   0.000008 if go#config#HighlightGenerateTags()
                              syn match       goGenerateVariables contained /\%(\$GOARCH\|\$GOOS\|\$GOFILE\|\$GOLINE\|\$GOPACKAGE\|\$DOLLAR\)\>/
                              syn region      goGenerate          start="^\s*//go:generate" end="$" contains=goGenerateVariables
                              hi def link     goGenerate          PreProc
                              hi def link     goGenerateVariables Special
    1              0.000001 endif
                            
                            " Go escapes
    1              0.000005 syn match       goEscapeOctal       display contained "\\[0-7]\{3}"
    1              0.000005 syn match       goEscapeC           display contained +\\[abfnrtv\\'"]+
    1              0.000005 syn match       goEscapeX           display contained "\\x\x\{2}"
    1              0.000004 syn match       goEscapeU           display contained "\\u\x\{4}"
    1              0.000004 syn match       goEscapeBigU        display contained "\\U\x\{8}"
    1              0.000005 syn match       goEscapeError       display contained +\\[^0-7xuUabfnrtv\\'"]+
                            
    1              0.000003 hi def link     goEscapeOctal       goSpecialString
    1              0.000003 hi def link     goEscapeC           goSpecialString
    1              0.000004 hi def link     goEscapeX           goSpecialString
    1              0.000003 hi def link     goEscapeU           goSpecialString
    1              0.000003 hi def link     goEscapeBigU        goSpecialString
    1              0.000004 hi def link     goSpecialString     Special
    1              0.000004 hi def link     goEscapeError       Error
                            
                            " Strings and their contents
    1              0.000017 syn cluster     goStringGroup       contains=goEscapeOctal,goEscapeC,goEscapeX,goEscapeU,goEscapeBigU,goEscapeError
    1   0.000011   0.000007 if go#config#HighlightStringSpellcheck()
    1              0.000015   syn region      goString            start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=@goStringGroup,@Spell
    1              0.000006   syn region      goRawString         start=+`+ end=+`+ contains=@Spell
                            else
                              syn region      goString            start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=@goStringGroup
                              syn region      goRawString         start=+`+ end=+`+
    1              0.000001 endif
                            
    1              0.000011 syn match       goImportString      /^\%(\s\+\|import \)\(\h\w* \)\?\zs"[^"]\+"$/ contained containedin=goImport
                            
    1   0.000011   0.000008 if go#config#HighlightFormatStrings()
                              " [n] notation is valid for specifying explicit argument indexes
                              " 1. Match a literal % not preceded by a %.
                              " 2. Match any number of -, #, 0, space, or +
                              " 3. Match * or [n]* or any number or nothing before a .
                              " 4. Match * or [n]* or any number or nothing after a .
                              " 5. Match [n] or nothing before a verb
                              " 6. Match a formatting verb
    1              0.000018   syn match       goFormatSpecifier   /\
                                    \%([^%]\%(%%\)*\)\
                                    \@<=%[-#0 +]*\
                                    \%(\%(\%(\[\d\+\]\)\=\*\)\|\d\+\)\=\
                                    \%(\.\%(\%(\%(\[\d\+\]\)\=\*\)\|\d\+\)\=\)\=\
                                    \%(\[\d\+\]\)\=[vTtbcdoqxXUeEfFgGspw]/ contained containedin=goString,goRawString
    1              0.000004   hi def link     goFormatSpecifier   goSpecialString
    1              0.000001 endif
                            
    1              0.000004 hi def link     goImportString      String
    1              0.000004 hi def link     goString            String
    1              0.000004 hi def link     goRawString         String
                            
                            " Characters; their contents
    1              0.000014 syn cluster     goCharacterGroup    contains=goEscapeOctal,goEscapeC,goEscapeX,goEscapeU,goEscapeBigU
    1              0.000008 syn region      goCharacter         start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=@goCharacterGroup
                            
    1              0.000004 hi def link     goCharacter         Character
                            
                            " Regions
    1              0.000005 syn region      goParen             start='(' end=')' transparent
    1   0.000024   0.000008 if go#config#FoldEnable('block')
    1              0.000005   syn region    goBlock             start="{" end="}" transparent fold
                            else
                              syn region    goBlock             start="{" end="}" transparent
    1              0.000000 endif
                            
                            " import
    1   0.000020   0.000006 if go#config#FoldEnable('import')
    1              0.000015   syn region    goImport            start='import (' end=')' transparent fold contains=goImport,goImportString,goComment
                            else
                              syn region    goImport            start='import (' end=')' transparent contains=goImport,goImportString,goComment
    1              0.000001 endif
                            
                            " var, const
    1   0.000019   0.000006 if go#config#FoldEnable('varconst')
    1              0.000030   syn region    goVar               start='var ('   end='^\s*)$' transparent fold
                                                    \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
    1              0.000029   syn region    goConst             start='const (' end='^\s*)$' transparent fold
                                                    \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                            else
                              syn region    goVar               start='var ('   end='^\s*)$' transparent
                                                    \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                              syn region    goConst             start='const (' end='^\s*)$' transparent
                                                    \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
    1              0.000001 endif
                            
                            " Single-line var, const, and import.
    1              0.000014 syn match       goSingleDecl        /\%(import\|var\|const\) [^(]\@=/ contains=goImport,goVar,goConst
                            
                            " Integers
    1              0.000007 syn match       goDecimalInt        "\<-\=\(0\|[1-9]_\?\(\d\|\d\+_\?\d\+\)*\)\%([Ee][-+]\=\d\+\)\=\>"
    1              0.000009 syn match       goDecimalError      "\<-\=\(_\(\d\+_*\)\+\|\([1-9]\d*_*\)\+__\(\d\+_*\)\+\|\([1-9]\d*_*\)\+_\+\)\%([Ee][-+]\=\d\+\)\=\>"
    1              0.000005 syn match       goHexadecimalInt    "\<-\=0[xX]_\?\(\x\+_\?\)\+\>"
    1              0.000007 syn match       goHexadecimalError  "\<-\=0[xX]_\?\(\x\+_\?\)*\(\([^ \t0-9A-Fa-f_)]\|__\)\S*\|_\)\>"
    1              0.000004 syn match       goOctalInt          "\<-\=0[oO]\?_\?\(\o\+_\?\)\+\>"
    1              0.000013 syn match       goOctalError        "\<-\=0[0-7oO_]*\(\([^ \t0-7oOxX_/)\]\}\:;]\|[oO]\{2,\}\|__\)\S*\|_\|[oOxX]\)\>"
    1              0.000005 syn match       goBinaryInt         "\<-\=0[bB]_\?\([01]\+_\?\)\+\>"
    1              0.000006 syn match       goBinaryError       "\<-\=0[bB]_\?[01_]*\([^ \t01_)]\S*\|__\S*\|_\)\>"
                            
    1              0.000003 hi def link     goDecimalInt        Integer
    1              0.000005 hi def link     goDecimalError      Error
    1              0.000003 hi def link     goHexadecimalInt    Integer
    1              0.000004 hi def link     goHexadecimalError  Error
    1              0.000003 hi def link     goOctalInt          Integer
    1              0.000003 hi def link     goOctalError        Error
    1              0.000003 hi def link     goBinaryInt         Integer
    1              0.000004 hi def link     goBinaryError       Error
    1              0.000004 hi def link     Integer             Number
                            
                            " Floating point
    1              0.000005 syn match       goFloat             "\<-\=\d\+\.\d*\%([Ee][-+]\=\d\+\)\=\>"
    1              0.000004 syn match       goFloat             "\<-\=\.\d\+\%([Ee][-+]\=\d\+\)\=\>"
                            
    1              0.000004 hi def link     goFloat             Float
                            
                            " Imaginary literals
    1              0.000003 syn match       goImaginary         "\<-\=\d\+i\>"
    1              0.000005 syn match       goImaginary         "\<-\=\d\+[Ee][-+]\=\d\+i\>"
    1              0.000006 syn match       goImaginaryFloat    "\<-\=\d\+\.\d*\%([Ee][-+]\=\d\+\)\=i\>"
    1              0.000004 syn match       goImaginaryFloat    "\<-\=\.\d\+\%([Ee][-+]\=\d\+\)\=i\>"
                            
    1              0.000004 hi def link     goImaginary         Number
    1              0.000005 hi def link     goImaginaryFloat    Float
                            
                            " Spaces after "[]"
    1   0.000013   0.000008 if go#config#HighlightArrayWhitespaceError()
                              syn match goSpaceError display "\%(\[\]\)\@<=\s\+"
    1              0.000001 endif
                            
                            " Spacing errors around the 'chan' keyword
    1   0.000010   0.000007 if go#config#HighlightChanWhitespaceError()
                              " receive-only annotation on chan type
                              "
                              " \(\<chan\>\)\@<!<-  (only pick arrow when it doesn't come after a chan)
                              " this prevents picking up 'chan<- chan<-' but not '<- chan'
                              syn match goSpaceError display "\%(\%(\<chan\>\)\@<!<-\)\@<=\s\+\%(\<chan\>\)\@="
                            
                              " send-only annotation on chan type
                              "
                              " \(<-\)\@<!\<chan\>  (only pick chan when it doesn't come after an arrow)
                              " this prevents picking up '<-chan <-chan' but not 'chan <-'
                              syn match goSpaceError display "\%(\%(<-\)\@<!\<chan\>\)\@<=\s\+\%(<-\)\@="
                            
                              " value-ignoring receives in a few contexts
                              syn match goSpaceError display "\%(\%(^\|[={(,;]\)\s*<-\)\@<=\s\+"
    1              0.000001 endif
                            
                            " Extra types commonly seen
    1   0.000009   0.000006 if go#config#HighlightExtraTypes()
                              syn match goExtraType /\<bytes\.\%(Buffer\)\>/
                              syn match goExtraType /\<context\.\%(Context\)\>/
                              syn match goExtraType /\<io\.\%(Reader\|ReadSeeker\|ReadWriter\|ReadCloser\|ReadWriteCloser\|Writer\|WriteCloser\|Seeker\)\>/
                              syn match goExtraType /\<reflect\.\%(Kind\|Type\|Value\)\>/
                              syn match goExtraType /\<unsafe\.Pointer\>/
    1              0.000001 endif
                            
                            " Space-tab error
    1   0.000012   0.000008 if go#config#HighlightSpaceTabError()
                              syn match goSpaceError display " \+\t"me=e-1
    1              0.000001 endif
                            
                            " Trailing white space error
    1   0.000010   0.000007 if go#config#HighlightTrailingWhitespaceError()
                              syn match goSpaceError display excludenl "\s\+$"
    1              0.000001 endif
                            
    1              0.000007 hi def link     goExtraType         Type
    1              0.000009 hi def link     goSpaceError        Error
                            
                            
                            
                            " included from: https://github.com/athom/more-colorful.vim/blob/master/after/syntax/go.vim
                            "
                            " Comments; their contents
    1              0.000004 syn keyword     goTodo              contained NOTE
    1              0.000004 hi def link     goTodo              Todo
                            
    1              0.000006 syn match goVarArgs /\.\.\./
                            
                            " Operators;
    1   0.000010   0.000007 if go#config#HighlightOperators()
                              " match single-char operators:          - + % < > ! & | ^ * =
                              " and corresponding two-char operators: -= += %= <= >= != &= |= ^= *= ==
                              syn match goOperator /[-+%<>!&|^*=]=\?/
                              " match / and /=
                              syn match goOperator /\/\%(=\|\ze[^/*]\)/
                              " match two-char operators:               << >> &^
                              " and corresponding three-char operators: <<= >>= &^=
                              syn match goOperator /\%(<<\|>>\|&^\)=\?/
                              " match remaining two-char operators: := && || <- ++ --
                              syn match goOperator /:=\|||\|<-\|++\|--/
                              " match ...
                            
                              hi def link     goPointerOperator   goOperator
                              hi def link     goVarArgs           goOperator
    1              0.000001 endif
    1              0.000004 hi def link     goOperator          Operator
                            
                            " Functions;
    1   0.000022   0.000013 if go#config#HighlightFunctions() || go#config#HighlightFunctionParameters()
                              syn match goDeclaration       /\<func\>/ nextgroup=goReceiver,goFunction,goSimpleParams skipwhite skipnl
                              syn match goReceiverDecl      /(\s*\zs\%(\%(\w\+\s\+\)\?\*\?\w\+\)\ze\s*)/ contained contains=goReceiverVar,goReceiverType,goPointerOperator
                              syn match goReceiverVar       /\w\+\ze\s\+\%(\w\|\*\)/ nextgroup=goPointerOperator,goReceiverType skipwhite skipnl contained
                              syn match goPointerOperator   /\*/ nextgroup=goReceiverType contained skipwhite skipnl
                              syn match goFunction          /\w\+/ nextgroup=goSimpleParams contained skipwhite skipnl
                              syn match goReceiverType      /\w\+\ze\s*)/ contained
                              if go#config#HighlightFunctionParameters()
                                syn match goSimpleParams      /(\%(\w\|\_s\|[*\.\[\],\{\}<>-]\)*)/ contained contains=goParamName,goType nextgroup=goFunctionReturn skipwhite skipnl
                                syn match goFunctionReturn   /(\%(\w\|\_s\|[*\.\[\],\{\}<>-]\)*)/ contained contains=goParamName,goType skipwhite skipnl
                                syn match goParamName        /\w\+\%(\s*,\s*\w\+\)*\ze\s\+\%(\w\|\.\|\*\|\[\)/ contained nextgroup=goParamType skipwhite skipnl
                                syn match goParamType        /\%([^,)]\|\_s\)\+,\?/ contained nextgroup=goParamName skipwhite skipnl
                                                      \ contains=goVarArgs,goType,goSignedInts,goUnsignedInts,goFloats,goComplexes,goDeclType,goBlock
                                hi def link   goReceiverVar    goParamName
                                hi def link   goParamName      Identifier
                              endif
                              syn match goReceiver          /(\s*\%(\w\+\s\+\)\?\*\?\s*\w\+\s*)\ze\s*\w/ contained nextgroup=goFunction contains=goReceiverDecl skipwhite skipnl
    1              0.000001 else
    1              0.000003   syn keyword goDeclaration func
    1              0.000000 endif
    1              0.000005 hi def link     goFunction          Function
                            
                            " Function calls;
    1   0.000011   0.000007 if go#config#HighlightFunctionCalls()
                              syn match goFunctionCall      /\w\+\ze(/ contains=goBuiltins,goDeclaration
    1              0.000001 endif
    1              0.000004 hi def link     goFunctionCall      Type
                            
                            " Fields;
    1   0.000009   0.000006 if go#config#HighlightFields()
                              " 1. Match a sequence of word characters coming after a '.'
                              " 2. Require the following but dont match it: ( \@= see :h E59)
                              "    - The symbols: / - + * %   OR
                              "    - The symbols: [] {} <> )  OR
                              "    - The symbols: \n \r space OR
                              "    - The symbols: , : .
                              " 3. Have the start of highlight (hs) be the start of matched
                              "    pattern (s) offsetted one to the right (+1) (see :h E401)
                              syn match       goField   /\.\w\+\
                                    \%(\%([\/\-\+*%]\)\|\
                                    \%([\[\]{}<\>\)]\)\|\
                                    \%([\!=\^|&]\)\|\
                                    \%([\n\r\ ]\)\|\
                                    \%([,\:.]\)\)\@=/hs=s+1
    1              0.000001 endif
    1              0.000005 hi def link    goField              Identifier
                            
                            " Structs & Interfaces;
    1   0.000009   0.000005 if go#config#HighlightTypes()
                              syn match goTypeConstructor      /\<\w\+{\@=/
                              syn match goTypeDecl             /\<type\>/ nextgroup=goTypeName skipwhite skipnl
                              syn match goTypeName             /\w\+/ contained nextgroup=goDeclType skipwhite skipnl
                              syn match goDeclType             /\<\%(interface\|struct\)\>/ skipwhite skipnl
                              hi def link     goReceiverType      Type
    1              0.000001 else
    1              0.000002   syn keyword goDeclType           struct interface
    1              0.000003   syn keyword goDeclaration        type
    1              0.000000 endif
    1              0.000004 hi def link     goTypeConstructor   Type
    1              0.000004 hi def link     goTypeName          Type
    1              0.000004 hi def link     goTypeDecl          Keyword
    1              0.000004 hi def link     goDeclType          Keyword
                            
                            " Variable Assignments
    1   0.000011   0.000007 if go#config#HighlightVariableAssignments()
                              syn match goVarAssign /\v[_.[:alnum:]]+(,\s*[_.[:alnum:]]+)*\ze(\s*([-^+|^\/%&]|\*|\<\<|\>\>|\&\^)?\=[^=])/
                              hi def link   goVarAssign         Special
    1              0.000000 endif
                            
                            " Variable Declarations
    1   0.000011   0.000008 if go#config#HighlightVariableDeclarations()
                              syn match goVarDefs /\v\w+(,\s*\w+)*\ze(\s*:\=)/
                              hi def link   goVarDefs           Special
    1              0.000001 endif
                            
                            " Build Constraints
    1   0.000015   0.000012 if go#config#HighlightBuildConstraints()
                              syn match   goBuildKeyword      display contained "+build\|go:build"
                              " Highlight the known values of GOOS, GOARCH, and other +build options.
                              syn keyword goBuildDirectives   contained
                                    \ android darwin dragonfly freebsd linux nacl netbsd openbsd plan9
                                    \ solaris windows 386 amd64 amd64p32 arm armbe arm64 arm64be ppc64
                                    \ ppc64le mips mipsle mips64 mips64le mips64p32 mips64p32le ppc
                                    \ s390 s390x sparc sparc64 cgo ignore race
                            
                              " Other words in the build directive are build tags not listed above, so
                              " avoid highlighting them as comments by using a matchgroup just for the
                              " start of the comment.
                              " The rs=s+2 option lets the \s*+build portion be part of the inner region
                              " instead of the matchgroup so it will be highlighted as a goBuildKeyword.
                              syn region  goBuildComment      matchgroup=goBuildCommentStart
                                    \ start="//\(\s*+build\s\|go:build\)"rs=s+2 end="$"
                                    \ contains=goBuildKeyword,goBuildDirectives
                              hi def link goBuildCommentStart Comment
                              hi def link goBuildDirectives   Type
                              hi def link goBuildKeyword      PreProc
    1              0.000000 endif
                            
    1   0.000224   0.000012 if go#config#HighlightBuildConstraints() || go#config#FoldEnable('package_comment')
                              " One or more line comments that are followed immediately by a "package"
                              " declaration are treated like package documentation, so these must be
                              " matched as comments to avoid looking like working build constraints.
                              " The he, me, and re options let the "package" itself be highlighted by
                              " the usual rules.
    1   0.000251   0.000234   exe 'syn region  goPackageComment    start=/\v(\/\/.*\n)+\s*package/'
                                    \ . ' end=/\v\n\s*package/he=e-7,me=e-7,re=e-7'
                                    \ . ' contains=@goCommentGroup,@Spell'
                                    \ . (go#config#FoldEnable('package_comment') ? ' fold' : '')
    1   0.000179   0.000154   exe 'syn region  goPackageComment    start=/\v^\s*\/\*.*\n(.*\n)*\s*\*\/\npackage/'
                                    \ . ' end=/\v\*\/\n\s*package/he=e-7,me=e-7,re=e-7'
                                    \ . ' contains=@goCommentGroup,@Spell'
                                    \ . (go#config#FoldEnable('package_comment') ? ' fold' : '')
    1              0.000009   hi def link goPackageComment    Comment
    1              0.000002 endif
                            
                            " :GoCoverage commands
    1              0.000005 hi def link goCoverageNormalText Comment
                            
    1              0.000005 function! s:hi()
                              hi def link goSameId Search
                              hi def link goDiagnosticError SpellBad
                              hi def link goDiagnosticWarning SpellRare
                            
                              " TODO(bc): is it appropriate to define text properties in a syntax file?
                              " The highlight groups need to be defined before the text properties types
                              " are added, and when users have syntax enabled in their vimrc after
                              " filetype plugin on, the highlight groups won't be defined when
                              " ftplugin/go.vim is executed when the first go file is opened.
                              " See https://github.com/fatih/vim-go/issues/2658.
                              if has('textprop')
                                if empty(prop_type_get('goSameId'))
                                  call prop_type_add('goSameId', {'highlight': 'goSameId'})
                                endif
                                if empty(prop_type_get('goDiagnosticError'))
                                  call prop_type_add('goDiagnosticError', {'highlight': 'goDiagnosticError'})
                                endif
                                if empty(prop_type_get('goDiagnosticWarning'))
                                  call prop_type_add('goDiagnosticWarning', {'highlight': 'goDiagnosticWarning'})
                                endif
                              endif
                            
                              hi def link goDeclsFzfKeyword        Keyword
                              hi def link goDeclsFzfFunction       Function
                              hi def link goDeclsFzfSpecialComment SpecialComment
                              hi def link goDeclsFzfComment        Comment
                            
                              " :GoCoverage commands
                              hi def      goCoverageCovered    ctermfg=green guifg=#A6E22E
                              hi def      goCoverageUncover    ctermfg=red guifg=#F92672
                            
                              " :GoDebug commands
                              if go#config#HighlightDebug()
                                hi def GoDebugBreakpoint term=standout ctermbg=117 ctermfg=0 guibg=#BAD4F5  guifg=Black
                                hi def GoDebugCurrent term=reverse  ctermbg=12  ctermfg=7 guibg=DarkBlue guifg=White
                              endif
                            endfunction
                            
    1              0.000004 augroup vim-go-hi
    1              0.000087   autocmd!
    1              0.000008   autocmd ColorScheme * call s:hi()
    1              0.000001 augroup end
    1   0.000104   0.000012 call s:hi()
                            
                            " Search backwards for a global declaration to start processing the syntax.
                            "syn sync match goSync grouphere NONE /^\(const\|var\|type\|func\)\>/
                            
                            " There's a bug in the implementation of grouphere. For now, use the
                            " following as a more expensive/less precise workaround.
    1              0.000003 syn sync minlines=500
                            
    1              0.000004 let b:current_syntax = "go"
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /Users/ryan/.vim/bundle/vim-polyglot/syntax/go.vim
Sourced 1 time
Total time:   0.000059
 Self time:   0.000034

count  total (s)   self (s)
    1   0.000042   0.000017 if polyglot#init#is_disabled(expand('<sfile>:p'), 'go', 'syntax/go.vim')
                              finish
    1              0.000001 endif
                            
                            " Copyright 2009 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " go.vim: Vim syntax file for Go.
                            
                            " Quit when a (custom) syntax file was already loaded
    1              0.000003 if exists("b:current_syntax")
    1              0.000001   finish
                            endif
                            
                            syn case match
                            
                            syn keyword     goPackage           package
                            syn keyword     goImport            import    contained
                            syn keyword     goVar               var       contained
                            syn keyword     goConst             const     contained
                            
                            hi def link     goPackage           Statement
                            hi def link     goImport            Statement
                            hi def link     goVar               Keyword
                            hi def link     goConst             Keyword
                            hi def link     goDeclaration       Keyword
                            
                            " Keywords within functions
                            syn keyword     goStatement         defer go goto return break continue fallthrough
                            syn keyword     goConditional       if else switch select
                            syn keyword     goLabel             case default
                            syn keyword     goRepeat            for range
                            
                            hi def link     goStatement         Statement
                            hi def link     goConditional       Conditional
                            hi def link     goLabel             Label
                            hi def link     goRepeat            Repeat
                            
                            " Predefined types
                            syn keyword     goType              chan map bool string error
                            syn keyword     goSignedInts        int int8 int16 int32 int64 rune
                            syn keyword     goUnsignedInts      byte uint uint8 uint16 uint32 uint64 uintptr
                            syn keyword     goFloats            float32 float64
                            syn keyword     goComplexes         complex64 complex128
                            
                            hi def link     goType              Type
                            hi def link     goSignedInts        Type
                            hi def link     goUnsignedInts      Type
                            hi def link     goFloats            Type
                            hi def link     goComplexes         Type
                            
                            " Predefined functions and values
                            syn keyword     goBuiltins                 append cap close complex copy delete imag len
                            syn keyword     goBuiltins                 make new panic print println real recover
                            syn keyword     goBoolean                  true false
                            syn keyword     goPredefinedIdentifiers    nil iota
                            
                            hi def link     goBuiltins                 Identifier
                            hi def link     goBoolean                  Boolean
                            hi def link     goPredefinedIdentifiers    goBoolean
                            
                            " Comments; their contents
                            syn keyword     goTodo              contained TODO FIXME XXX BUG
                            syn cluster     goCommentGroup      contains=goTodo
                            
                            syn region      goComment           start="//" end="$" contains=goGenerate,@goCommentGroup,@Spell
                            if go#config#FoldEnable('comment')
                              syn region    goComment           start="/\*" end="\*/" contains=@goCommentGroup,@Spell fold
                              syn match     goComment           "\v(^\s*//.*\n)+" contains=goGenerate,@goCommentGroup,@Spell fold
                            else
                              syn region    goComment           start="/\*" end="\*/" contains=@goCommentGroup,@Spell
                            endif
                            
                            hi def link     goComment           Comment
                            hi def link     goTodo              Todo
                            
                            if go#config#HighlightGenerateTags()
                              syn match       goGenerateVariables contained /\%(\$GOARCH\|\$GOOS\|\$GOFILE\|\$GOLINE\|\$GOPACKAGE\|\$DOLLAR\)\>/
                              syn region      goGenerate          start="^\s*//go:generate" end="$" contains=goGenerateVariables
                              hi def link     goGenerate          PreProc
                              hi def link     goGenerateVariables Special
                            endif
                            
                            " Go escapes
                            syn match       goEscapeOctal       display contained "\\[0-7]\{3}"
                            syn match       goEscapeC           display contained +\\[abfnrtv\\'"]+
                            syn match       goEscapeX           display contained "\\x\x\{2}"
                            syn match       goEscapeU           display contained "\\u\x\{4}"
                            syn match       goEscapeBigU        display contained "\\U\x\{8}"
                            syn match       goEscapeError       display contained +\\[^0-7xuUabfnrtv\\'"]+
                            
                            hi def link     goEscapeOctal       goSpecialString
                            hi def link     goEscapeC           goSpecialString
                            hi def link     goEscapeX           goSpecialString
                            hi def link     goEscapeU           goSpecialString
                            hi def link     goEscapeBigU        goSpecialString
                            hi def link     goSpecialString     Special
                            hi def link     goEscapeError       Error
                            
                            " Strings and their contents
                            syn cluster     goStringGroup       contains=goEscapeOctal,goEscapeC,goEscapeX,goEscapeU,goEscapeBigU,goEscapeError
                            if go#config#HighlightStringSpellcheck()
                              syn region      goString            start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=@goStringGroup,@Spell
                              syn region      goRawString         start=+`+ end=+`+ contains=@Spell
                            else
                              syn region      goString            start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=@goStringGroup
                              syn region      goRawString         start=+`+ end=+`+
                            endif
                            
                            if go#config#HighlightFormatStrings()
                              " [n] notation is valid for specifying explicit argument indexes
                              " 1. Match a literal % not preceded by a %.
                              " 2. Match any number of -, #, 0, space, or +
                              " 3. Match * or [n]* or any number or nothing before a .
                              " 4. Match * or [n]* or any number or nothing after a .
                              " 5. Match [n] or nothing before a verb
                              " 6. Match a formatting verb
                              syn match       goFormatSpecifier   /\
                                    \%([^%]\%(%%\)*\)\
                                    \@<=%[-#0 +]*\
                                    \%(\%(\%(\[\d\+\]\)\=\*\)\|\d\+\)\=\
                                    \%(\.\%(\%(\%(\[\d\+\]\)\=\*\)\|\d\+\)\=\)\=\
                                    \%(\[\d\+\]\)\=[vTtbcdoqxXUeEfFgGspw]/ contained containedin=goString,goRawString
                              hi def link     goFormatSpecifier   goSpecialString
                            endif
                            
                            hi def link     goString            String
                            hi def link     goRawString         String
                            
                            " Characters; their contents
                            syn cluster     goCharacterGroup    contains=goEscapeOctal,goEscapeC,goEscapeX,goEscapeU,goEscapeBigU
                            syn region      goCharacter         start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=@goCharacterGroup
                            
                            hi def link     goCharacter         Character
                            
                            " Regions
                            syn region      goParen             start='(' end=')' transparent
                            if go#config#FoldEnable('block')
                              syn region    goBlock             start="{" end="}" transparent fold
                            else
                              syn region    goBlock             start="{" end="}" transparent
                            endif
                            
                            " import
                            if go#config#FoldEnable('import')
                              syn region    goImport            start='import (' end=')' transparent fold contains=goImport,goString,goComment
                            else
                              syn region    goImport            start='import (' end=')' transparent contains=goImport,goString,goComment
                            endif
                            
                            " var, const
                            if go#config#FoldEnable('varconst')
                              syn region    goVar               start='var ('   end='^\s*)$' transparent fold
                                                    \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                              syn region    goConst             start='const (' end='^\s*)$' transparent fold
                                                    \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                            else
                              syn region    goVar               start='var ('   end='^\s*)$' transparent
                                                    \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                              syn region    goConst             start='const (' end='^\s*)$' transparent
                                                    \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                            endif
                            
                            " Single-line var, const, and import.
                            syn match       goSingleDecl        /\%(import\|var\|const\) [^(]\@=/ contains=goImport,goVar,goConst
                            
                            " Integers
                            syn match       goDecimalInt        "\<-\=\(0\|[1-9]_\?\(\d\|\d\+_\?\d\+\)*\)\%([Ee][-+]\=\d\+\)\=\>"
                            syn match       goDecimalError      "\<-\=\(_\(\d\+_*\)\+\|\([1-9]\d*_*\)\+__\(\d\+_*\)\+\|\([1-9]\d*_*\)\+_\+\)\%([Ee][-+]\=\d\+\)\=\>"
                            syn match       goHexadecimalInt    "\<-\=0[xX]_\?\(\x\+_\?\)\+\>"
                            syn match       goHexadecimalError  "\<-\=0[xX]_\?\(\x\+_\?\)*\(\([^ \t0-9A-Fa-f_]\|__\)\S*\|_\)\>"
                            syn match       goOctalInt          "\<-\=0[oO]\?_\?\(\o\+_\?\)\+\>"
                            syn match       goOctalError        "\<-\=0[0-7oO_]*\(\([^ \t0-7oOxX_/)\]\}\:]\|[oO]\{2,\}\|__\)\S*\|_\|[oOxX]\)\>"
                            syn match       goBinaryInt         "\<-\=0[bB]_\?\([01]\+_\?\)\+\>"
                            syn match       goBinaryError       "\<-\=0[bB]_\?[01_]*\([^ \t01_]\S*\|__\S*\|_\)\>"
                            
                            hi def link     goDecimalInt        Integer
                            hi def link     goDecimalError      Error
                            hi def link     goHexadecimalInt    Integer
                            hi def link     goHexadecimalError  Error
                            hi def link     goOctalInt          Integer
                            hi def link     goOctalError        Error
                            hi def link     goBinaryInt         Integer
                            hi def link     goBinaryError       Error
                            hi def link     Integer             Number
                            
                            " Floating point
                            syn match       goFloat             "\<-\=\d\+\.\d*\%([Ee][-+]\=\d\+\)\=\>"
                            syn match       goFloat             "\<-\=\.\d\+\%([Ee][-+]\=\d\+\)\=\>"
                            
                            hi def link     goFloat             Float
                            
                            " Imaginary literals
                            syn match       goImaginary         "\<-\=\d\+i\>"
                            syn match       goImaginary         "\<-\=\d\+[Ee][-+]\=\d\+i\>"
                            syn match       goImaginaryFloat    "\<-\=\d\+\.\d*\%([Ee][-+]\=\d\+\)\=i\>"
                            syn match       goImaginaryFloat    "\<-\=\.\d\+\%([Ee][-+]\=\d\+\)\=i\>"
                            
                            hi def link     goImaginary         Number
                            hi def link     goImaginaryFloat    Float
                            
                            " Spaces after "[]"
                            if go#config#HighlightArrayWhitespaceError()
                              syn match goSpaceError display "\%(\[\]\)\@<=\s\+"
                            endif
                            
                            " Spacing errors around the 'chan' keyword
                            if go#config#HighlightChanWhitespaceError()
                              " receive-only annotation on chan type
                              "
                              " \(\<chan\>\)\@<!<-  (only pick arrow when it doesn't come after a chan)
                              " this prevents picking up 'chan<- chan<-' but not '<- chan'
                              syn match goSpaceError display "\%(\%(\<chan\>\)\@<!<-\)\@<=\s\+\%(\<chan\>\)\@="
                            
                              " send-only annotation on chan type
                              "
                              " \(<-\)\@<!\<chan\>  (only pick chan when it doesn't come after an arrow)
                              " this prevents picking up '<-chan <-chan' but not 'chan <-'
                              syn match goSpaceError display "\%(\%(<-\)\@<!\<chan\>\)\@<=\s\+\%(<-\)\@="
                            
                              " value-ignoring receives in a few contexts
                              syn match goSpaceError display "\%(\%(^\|[={(,;]\)\s*<-\)\@<=\s\+"
                            endif
                            
                            " Extra types commonly seen
                            if go#config#HighlightExtraTypes()
                              syn match goExtraType /\<bytes\.\%(Buffer\)\>/
                              syn match goExtraType /\<context\.\%(Context\)\>/
                              syn match goExtraType /\<io\.\%(Reader\|ReadSeeker\|ReadWriter\|ReadCloser\|ReadWriteCloser\|Writer\|WriteCloser\|Seeker\)\>/
                              syn match goExtraType /\<reflect\.\%(Kind\|Type\|Value\)\>/
                              syn match goExtraType /\<unsafe\.Pointer\>/
                            endif
                            
                            " Space-tab error
                            if go#config#HighlightSpaceTabError()
                              syn match goSpaceError display " \+\t"me=e-1
                            endif
                            
                            " Trailing white space error
                            if go#config#HighlightTrailingWhitespaceError()
                              syn match goSpaceError display excludenl "\s\+$"
                            endif
                            
                            hi def link     goExtraType         Type
                            hi def link     goSpaceError        Error
                            
                            
                            
                            " included from: https://github.com/athom/more-colorful.vim/blob/master/after/syntax/go.vim
                            "
                            " Comments; their contents
                            syn keyword     goTodo              contained NOTE
                            hi def link     goTodo              Todo
                            
                            syn match goVarArgs /\.\.\./
                            
                            " Operators;
                            if go#config#HighlightOperators()
                              " match single-char operators:          - + % < > ! & | ^ * =
                              " and corresponding two-char operators: -= += %= <= >= != &= |= ^= *= ==
                              syn match goOperator /[-+%<>!&|^*=]=\?/
                              " match / and /=
                              syn match goOperator /\/\%(=\|\ze[^/*]\)/
                              " match two-char operators:               << >> &^
                              " and corresponding three-char operators: <<= >>= &^=
                              syn match goOperator /\%(<<\|>>\|&^\)=\?/
                              " match remaining two-char operators: := && || <- ++ --
                              syn match goOperator /:=\|||\|<-\|++\|--/
                              " match ...
                            
                              hi def link     goPointerOperator   goOperator
                              hi def link     goVarArgs           goOperator
                            endif
                            hi def link     goOperator          Operator
                            
                            " Functions;
                            if go#config#HighlightFunctions() || go#config#HighlightFunctionParameters()
                              syn match goDeclaration       /\<func\>/ nextgroup=goReceiver,goFunction,goSimpleParams skipwhite skipnl
                              syn match goReceiverVar       /\w\+\ze\s\+\%(\w\|\*\)/ nextgroup=goPointerOperator,goReceiverType skipwhite skipnl contained
                              syn match goPointerOperator   /\*/ nextgroup=goReceiverType contained skipwhite skipnl
                              syn match goFunction          /\w\+/ nextgroup=goSimpleParams contained skipwhite skipnl
                              syn match goReceiverType      /\w\+/ contained
                              if go#config#HighlightFunctionParameters()
                                syn match goSimpleParams      /(\%(\w\|\_s\|[*\.\[\],\{\}<>-]\)*)/ contained contains=goParamName,goType nextgroup=goFunctionReturn skipwhite skipnl
                                syn match goFunctionReturn   /(\%(\w\|\_s\|[*\.\[\],\{\}<>-]\)*)/ contained contains=goParamName,goType skipwhite skipnl
                                syn match goParamName        /\w\+\%(\s*,\s*\w\+\)*\ze\s\+\%(\w\|\.\|\*\|\[\)/ contained nextgroup=goParamType skipwhite skipnl
                                syn match goParamType        /\%([^,)]\|\_s\)\+,\?/ contained nextgroup=goParamName skipwhite skipnl
                                                      \ contains=goVarArgs,goType,goSignedInts,goUnsignedInts,goFloats,goComplexes,goDeclType,goBlock
                                hi def link   goReceiverVar    goParamName
                                hi def link   goParamName      Identifier
                              endif
                              syn match goReceiver          /(\s*\w\+\%(\s\+\*\?\s*\w\+\)\?\s*)\ze\s*\w/ contained nextgroup=goFunction contains=goReceiverVar skipwhite skipnl
                            else
                              syn keyword goDeclaration func
                            endif
                            hi def link     goFunction          Function
                            
                            " Function calls;
                            if go#config#HighlightFunctionCalls()
                              syn match goFunctionCall      /\w\+\ze(/ contains=goBuiltins,goDeclaration
                            endif
                            hi def link     goFunctionCall      Type
                            
                            " Fields;
                            if go#config#HighlightFields()
                              " 1. Match a sequence of word characters coming after a '.'
                              " 2. Require the following but dont match it: ( \@= see :h E59)
                              "    - The symbols: / - + * %   OR
                              "    - The symbols: [] {} <> )  OR
                              "    - The symbols: \n \r space OR
                              "    - The symbols: , : .
                              " 3. Have the start of highlight (hs) be the start of matched
                              "    pattern (s) offsetted one to the right (+1) (see :h E401)
                              syn match       goField   /\.\w\+\
                                    \%(\%([\/\-\+*%]\)\|\
                                    \%([\[\]{}<\>\)]\)\|\
                                    \%([\!=\^|&]\)\|\
                                    \%([\n\r\ ]\)\|\
                                    \%([,\:.]\)\)\@=/hs=s+1
                            endif
                            hi def link    goField              Identifier
                            
                            " Structs & Interfaces;
                            if go#config#HighlightTypes()
                              syn match goTypeConstructor      /\<\w\+{\@=/
                              syn match goTypeDecl             /\<type\>/ nextgroup=goTypeName skipwhite skipnl
                              syn match goTypeName             /\w\+/ contained nextgroup=goDeclType skipwhite skipnl
                              syn match goDeclType             /\<\%(interface\|struct\)\>/ skipwhite skipnl
                              hi def link     goReceiverType      Type
                            else
                              syn keyword goDeclType           struct interface
                              syn keyword goDeclaration        type
                            endif
                            hi def link     goTypeConstructor   Type
                            hi def link     goTypeName          Type
                            hi def link     goTypeDecl          Keyword
                            hi def link     goDeclType          Keyword
                            
                            " Variable Assignments
                            if go#config#HighlightVariableAssignments()
                              syn match goVarAssign /\v[_.[:alnum:]]+(,\s*[_.[:alnum:]]+)*\ze(\s*([-^+|^\/%&]|\*|\<\<|\>\>|\&\^)?\=[^=])/
                              hi def link   goVarAssign         Special
                            endif
                            
                            " Variable Declarations
                            if go#config#HighlightVariableDeclarations()
                              syn match goVarDefs /\v\w+(,\s*\w+)*\ze(\s*:\=)/
                              hi def link   goVarDefs           Special
                            endif
                            
                            " Build Constraints
                            if go#config#HighlightBuildConstraints()
                              syn match   goBuildKeyword      display contained "+build"
                              " Highlight the known values of GOOS, GOARCH, and other +build options.
                              syn keyword goBuildDirectives   contained
                                    \ android darwin dragonfly freebsd linux nacl netbsd openbsd plan9
                                    \ solaris windows 386 amd64 amd64p32 arm armbe arm64 arm64be ppc64
                                    \ ppc64le mips mipsle mips64 mips64le mips64p32 mips64p32le ppc
                                    \ s390 s390x sparc sparc64 cgo ignore race
                            
                              " Other words in the build directive are build tags not listed above, so
                              " avoid highlighting them as comments by using a matchgroup just for the
                              " start of the comment.
                              " The rs=s+2 option lets the \s*+build portion be part of the inner region
                              " instead of the matchgroup so it will be highlighted as a goBuildKeyword.
                              syn region  goBuildComment      matchgroup=goBuildCommentStart
                                    \ start="//\s*+build\s"rs=s+2 end="$"
                                    \ contains=goBuildKeyword,goBuildDirectives
                              hi def link goBuildCommentStart Comment
                              hi def link goBuildDirectives   Type
                              hi def link goBuildKeyword      PreProc
                            endif
                            
                            if go#config#HighlightBuildConstraints() || go#config#FoldEnable('package_comment')
                              " One or more line comments that are followed immediately by a "package"
                              " declaration are treated like package documentation, so these must be
                              " matched as comments to avoid looking like working build constraints.
                              " The he, me, and re options let the "package" itself be highlighted by
                              " the usual rules.
                              exe 'syn region  goPackageComment    start=/\v(\/\/.*\n)+\s*package/'
                                    \ . ' end=/\v\n\s*package/he=e-7,me=e-7,re=e-7'
                                    \ . ' contains=@goCommentGroup,@Spell'
                                    \ . (go#config#FoldEnable('package_comment') ? ' fold' : '')
                              exe 'syn region  goPackageComment    start=/\v^\s*\/\*.*\n(.*\n)*\s*\*\/\npackage/'
                                    \ . ' end=/\v\*\/\n\s*package/he=e-7,me=e-7,re=e-7'
                                    \ . ' contains=@goCommentGroup,@Spell'
                                    \ . (go#config#FoldEnable('package_comment') ? ' fold' : '')
                              hi def link goPackageComment    Comment
                            endif
                            
                            " :GoCoverage commands
                            hi def link goCoverageNormalText Comment
                            
                            function! s:hi()
                              hi def link goSameId Search
                              hi def link goDiagnosticError SpellBad
                              hi def link goDiagnosticWarning SpellRare
                            
                              " TODO(bc): is it appropriate to define text properties in a syntax file?
                              " The highlight groups need to be defined before the text properties types
                              " are added, and when users have syntax enabled in their vimrc after
                              " filetype plugin on, the highlight groups won't be defined when
                              " ftplugin/go.vim is executed when the first go file is opened.
                              " See https://github.com/fatih/vim-go/issues/2658.
                              if has('textprop')
                                if empty(prop_type_get('goSameId'))
                                  call prop_type_add('goSameId', {'highlight': 'goSameId'})
                                endif
                                if empty(prop_type_get('goDiagnosticError'))
                                  call prop_type_add('goDiagnosticError', {'highlight': 'goDiagnosticError'})
                                endif
                                if empty(prop_type_get('goDiagnosticWarning'))
                                  call prop_type_add('goDiagnosticWarning', {'highlight': 'goDiagnosticWarning'})
                                endif
                              endif
                            
                              hi def link goDeclsFzfKeyword        Keyword
                              hi def link goDeclsFzfFunction       Function
                              hi def link goDeclsFzfSpecialComment SpecialComment
                              hi def link goDeclsFzfComment        Comment
                            
                              " :GoCoverage commands
                              hi def      goCoverageCovered    ctermfg=green guifg=#A6E22E
                              hi def      goCoverageUncover    ctermfg=red guifg=#F92672
                            
                              " :GoDebug commands
                              if go#config#HighlightDebug()
                                hi def GoDebugBreakpoint term=standout ctermbg=117 ctermfg=0 guibg=#BAD4F5  guifg=Black
                                hi def GoDebugCurrent term=reverse  ctermbg=12  ctermfg=7 guibg=DarkBlue guifg=White
                              endif
                            endfunction
                            
                            augroup vim-go-hi
                              autocmd!
                              autocmd ColorScheme * call s:hi()
                            augroup end
                            call s:hi()
                            
                            " Search backwards for a global declaration to start processing the syntax.
                            "syn sync match goSync grouphere NONE /^\(const\|var\|type\|func\)\>/
                            
                            " There's a bug in the implementation of grouphere. For now, use the
                            " following as a more expensive/less precise workaround.
                            syn sync minlines=500
                            
                            let b:current_syntax = "go"
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /usr/local/Cellar/macvim/9.0.0065/MacVim.app/Contents/Resources/vim/runtime/syntax/go.vim
Sourced 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
                            " Copyright 2009 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " go.vim: Vim syntax file for Go.
                            " Language:             Go
                            " Maintainer:           Billie Cleek <bhcleek@gmail.com>
                            " Latest Revision:      2021-09-18
                            " License:              BSD-style. See LICENSE file in source repository.
                            " Repository:           https://github.com/fatih/vim-go
                            
                            " Quit when a (custom) syntax file was already loaded
    1              0.000007 if exists("b:current_syntax")
    1              0.000001   finish
                            endif
                            
                            let s:keepcpo = &cpo
                            set cpo&vim
                            
                            function! s:FoldEnable(...) abort
                              if a:0 > 0
                                return index(s:FoldEnable(), a:1) > -1
                              endif
                              return get(g:, 'go_fold_enable', ['block', 'import', 'varconst', 'package_comment'])
                            endfunction
                            
                            function! s:HighlightArrayWhitespaceError() abort
                              return get(g:, 'go_highlight_array_whitespace_error', 0)
                            endfunction
                            
                            function! s:HighlightChanWhitespaceError() abort
                              return get(g:, 'go_highlight_chan_whitespace_error', 0)
                            endfunction
                            
                            function! s:HighlightExtraTypes() abort
                              return get(g:, 'go_highlight_extra_types', 0)
                            endfunction
                            
                            function! s:HighlightSpaceTabError() abort
                              return get(g:, 'go_highlight_space_tab_error', 0)
                            endfunction
                            
                            function! s:HighlightTrailingWhitespaceError() abort
                              return get(g:, 'go_highlight_trailing_whitespace_error', 0)
                            endfunction
                            
                            function! s:HighlightOperators() abort
                              return get(g:, 'go_highlight_operators', 0)
                            endfunction
                            
                            function! s:HighlightFunctions() abort
                              return get(g:, 'go_highlight_functions', 0)
                            endfunction
                            
                            function! s:HighlightFunctionParameters() abort
                              return get(g:, 'go_highlight_function_parameters', 0)
                            endfunction
                            
                            function! s:HighlightFunctionCalls() abort
                              return get(g:, 'go_highlight_function_calls', 0)
                            endfunction
                            
                            function! s:HighlightFields() abort
                              return get(g:, 'go_highlight_fields', 0)
                            endfunction
                            
                            function! s:HighlightTypes() abort
                              return get(g:, 'go_highlight_types', 0)
                            endfunction
                            
                            function! s:HighlightBuildConstraints() abort
                              return get(g:, 'go_highlight_build_constraints', 0)
                            endfunction
                            
                            function! s:HighlightStringSpellcheck() abort
                              return get(g:, 'go_highlight_string_spellcheck', 1)
                            endfunction
                            
                            function! s:HighlightFormatStrings() abort
                              return get(g:, 'go_highlight_format_strings', 1)
                            endfunction
                            
                            function! s:HighlightGenerateTags() abort
                              return get(g:, 'go_highlight_generate_tags', 0)
                            endfunction
                            
                            function! s:HighlightVariableAssignments() abort
                              return get(g:, 'go_highlight_variable_assignments', 0)
                            endfunction
                            
                            function! s:HighlightVariableDeclarations() abort
                              return get(g:, 'go_highlight_variable_declarations', 0)
                            endfunction
                            
                            syn case match
                            
                            syn keyword     goPackage           package
                            syn keyword     goImport            import    contained
                            syn keyword     goVar               var       contained
                            syn keyword     goConst             const     contained
                            
                            hi def link     goPackage           Statement
                            hi def link     goImport            Statement
                            hi def link     goVar               Keyword
                            hi def link     goConst             Keyword
                            hi def link     goDeclaration       Keyword
                            
                            " Keywords within functions
                            syn keyword     goStatement         defer go goto return break continue fallthrough
                            syn keyword     goConditional       if else switch select
                            syn keyword     goLabel             case default
                            syn keyword     goRepeat            for range
                            
                            hi def link     goStatement         Statement
                            hi def link     goConditional       Conditional
                            hi def link     goLabel             Label
                            hi def link     goRepeat            Repeat
                            
                            " Predefined types
                            syn keyword     goType              chan map bool string error
                            syn keyword     goSignedInts        int int8 int16 int32 int64 rune
                            syn keyword     goUnsignedInts      byte uint uint8 uint16 uint32 uint64 uintptr
                            syn keyword     goFloats            float32 float64
                            syn keyword     goComplexes         complex64 complex128
                            
                            hi def link     goType              Type
                            hi def link     goSignedInts        Type
                            hi def link     goUnsignedInts      Type
                            hi def link     goFloats            Type
                            hi def link     goComplexes         Type
                            
                            " Predefined functions and values
                            syn keyword     goBuiltins                 append cap close complex copy delete imag len
                            syn keyword     goBuiltins                 make new panic print println real recover
                            syn keyword     goBoolean                  true false
                            syn keyword     goPredefinedIdentifiers    nil iota
                            
                            hi def link     goBuiltins                 Identifier
                            hi def link     goBoolean                  Boolean
                            hi def link     goPredefinedIdentifiers    goBoolean
                            
                            " Comments; their contents
                            syn keyword     goTodo              contained TODO FIXME XXX BUG
                            syn cluster     goCommentGroup      contains=goTodo
                            
                            syn region      goComment           start="//" end="$" contains=goGenerate,@goCommentGroup,@Spell
                            if s:FoldEnable('comment')
                              syn region    goComment           start="/\*" end="\*/" contains=@goCommentGroup,@Spell fold
                              syn match     goComment           "\v(^\s*//.*\n)+" contains=goGenerate,@goCommentGroup,@Spell fold
                            else
                              syn region    goComment           start="/\*" end="\*/" contains=@goCommentGroup,@Spell
                            endif
                            
                            hi def link     goComment           Comment
                            hi def link     goTodo              Todo
                            
                            if s:HighlightGenerateTags()
                              syn match       goGenerateVariables contained /\%(\$GOARCH\|\$GOOS\|\$GOFILE\|\$GOLINE\|\$GOPACKAGE\|\$DOLLAR\)\>/
                              syn region      goGenerate          start="^\s*//go:generate" end="$" contains=goGenerateVariables
                              hi def link     goGenerate          PreProc
                              hi def link     goGenerateVariables Special
                            endif
                            
                            " Go escapes
                            syn match       goEscapeOctal       display contained "\\[0-7]\{3}"
                            syn match       goEscapeC           display contained +\\[abfnrtv\\'"]+
                            syn match       goEscapeX           display contained "\\x\x\{2}"
                            syn match       goEscapeU           display contained "\\u\x\{4}"
                            syn match       goEscapeBigU        display contained "\\U\x\{8}"
                            syn match       goEscapeError       display contained +\\[^0-7xuUabfnrtv\\'"]+
                            
                            hi def link     goEscapeOctal       goSpecialString
                            hi def link     goEscapeC           goSpecialString
                            hi def link     goEscapeX           goSpecialString
                            hi def link     goEscapeU           goSpecialString
                            hi def link     goEscapeBigU        goSpecialString
                            hi def link     goSpecialString     Special
                            hi def link     goEscapeError       Error
                            
                            " Strings and their contents
                            syn cluster     goStringGroup       contains=goEscapeOctal,goEscapeC,goEscapeX,goEscapeU,goEscapeBigU,goEscapeError
                            if s:HighlightStringSpellcheck()
                              syn region      goString            start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=@goStringGroup,@Spell
                              syn region      goRawString         start=+`+ end=+`+ contains=@Spell
                            else
                              syn region      goString            start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=@goStringGroup
                              syn region      goRawString         start=+`+ end=+`+
                            endif
                            
                            if s:HighlightFormatStrings()
                              " [n] notation is valid for specifying explicit argument indexes
                              " 1. Match a literal % not preceded by a %.
                              " 2. Match any number of -, #, 0, space, or +
                              " 3. Match * or [n]* or any number or nothing before a .
                              " 4. Match * or [n]* or any number or nothing after a .
                              " 5. Match [n] or nothing before a verb
                              " 6. Match a formatting verb
                              syn match       goFormatSpecifier   /\
                                    \%([^%]\%(%%\)*\)\
                                    \@<=%[-#0 +]*\
                                    \%(\%(\%(\[\d\+\]\)\=\*\)\|\d\+\)\=\
                                    \%(\.\%(\%(\%(\[\d\+\]\)\=\*\)\|\d\+\)\=\)\=\
                                    \%(\[\d\+\]\)\=[vTtbcdoqxXUeEfFgGspw]/ contained containedin=goString,goRawString
                              hi def link     goFormatSpecifier   goSpecialString
                            endif
                            
                            hi def link     goString            String
                            hi def link     goRawString         String
                            
                            " Characters; their contents
                            syn cluster     goCharacterGroup    contains=goEscapeOctal,goEscapeC,goEscapeX,goEscapeU,goEscapeBigU
                            syn region      goCharacter         start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=@goCharacterGroup
                            
                            hi def link     goCharacter         Character
                            
                            " Regions
                            syn region      goParen             start='(' end=')' transparent
                            if s:FoldEnable('block')
                              syn region    goBlock             start="{" end="}" transparent fold
                            else
                              syn region    goBlock             start="{" end="}" transparent
                            endif
                            
                            " import
                            if s:FoldEnable('import')
                              syn region    goImport            start='import (' end=')' transparent fold contains=goImport,goString,goComment
                            else
                              syn region    goImport            start='import (' end=')' transparent contains=goImport,goString,goComment
                            endif
                            
                            " var, const
                            if s:FoldEnable('varconst')
                              syn region    goVar               start='var ('   end='^\s*)$' transparent fold
                                                    \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                              syn region    goConst             start='const (' end='^\s*)$' transparent fold
                                                    \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                            else
                              syn region    goVar               start='var ('   end='^\s*)$' transparent
                                                    \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                              syn region    goConst             start='const (' end='^\s*)$' transparent
                                                    \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                            endif
                            
                            " Single-line var, const, and import.
                            syn match       goSingleDecl        /\%(import\|var\|const\) [^(]\@=/ contains=goImport,goVar,goConst
                            
                            " Integers
                            syn match       goDecimalInt        "\<-\=\(0\|[1-9]_\?\(\d\|\d\+_\?\d\+\)*\)\%([Ee][-+]\=\d\+\)\=\>"
                            syn match       goDecimalError      "\<-\=\(_\(\d\+_*\)\+\|\([1-9]\d*_*\)\+__\(\d\+_*\)\+\|\([1-9]\d*_*\)\+_\+\)\%([Ee][-+]\=\d\+\)\=\>"
                            syn match       goHexadecimalInt    "\<-\=0[xX]_\?\(\x\+_\?\)\+\>"
                            syn match       goHexadecimalError  "\<-\=0[xX]_\?\(\x\+_\?\)*\(\([^ \t0-9A-Fa-f_)]\|__\)\S*\|_\)\>"
                            syn match       goOctalInt          "\<-\=0[oO]\?_\?\(\o\+_\?\)\+\>"
                            syn match       goOctalError        "\<-\=0[0-7oO_]*\(\([^ \t0-7oOxX_/)\]\}\:;]\|[oO]\{2,\}\|__\)\S*\|_\|[oOxX]\)\>"
                            syn match       goBinaryInt         "\<-\=0[bB]_\?\([01]\+_\?\)\+\>"
                            syn match       goBinaryError       "\<-\=0[bB]_\?[01_]*\([^ \t01_)]\S*\|__\S*\|_\)\>"
                            
                            hi def link     goDecimalInt        Integer
                            hi def link     goDecimalError      Error
                            hi def link     goHexadecimalInt    Integer
                            hi def link     goHexadecimalError  Error
                            hi def link     goOctalInt          Integer
                            hi def link     goOctalError        Error
                            hi def link     goBinaryInt         Integer
                            hi def link     goBinaryError       Error
                            hi def link     Integer             Number
                            
                            " Floating point
                            syn match       goFloat             "\<-\=\d\+\.\d*\%([Ee][-+]\=\d\+\)\=\>"
                            syn match       goFloat             "\<-\=\.\d\+\%([Ee][-+]\=\d\+\)\=\>"
                            
                            hi def link     goFloat             Float
                            
                            " Imaginary literals
                            syn match       goImaginary         "\<-\=\d\+i\>"
                            syn match       goImaginary         "\<-\=\d\+[Ee][-+]\=\d\+i\>"
                            syn match       goImaginaryFloat    "\<-\=\d\+\.\d*\%([Ee][-+]\=\d\+\)\=i\>"
                            syn match       goImaginaryFloat    "\<-\=\.\d\+\%([Ee][-+]\=\d\+\)\=i\>"
                            
                            hi def link     goImaginary         Number
                            hi def link     goImaginaryFloat    Float
                            
                            " Spaces after "[]"
                            if s:HighlightArrayWhitespaceError()
                              syn match goSpaceError display "\%(\[\]\)\@<=\s\+"
                            endif
                            
                            " Spacing errors around the 'chan' keyword
                            if s:HighlightChanWhitespaceError()
                              " receive-only annotation on chan type
                              "
                              " \(\<chan\>\)\@<!<-  (only pick arrow when it doesn't come after a chan)
                              " this prevents picking up 'chan<- chan<-' but not '<- chan'
                              syn match goSpaceError display "\%(\%(\<chan\>\)\@<!<-\)\@<=\s\+\%(\<chan\>\)\@="
                            
                              " send-only annotation on chan type
                              "
                              " \(<-\)\@<!\<chan\>  (only pick chan when it doesn't come after an arrow)
                              " this prevents picking up '<-chan <-chan' but not 'chan <-'
                              syn match goSpaceError display "\%(\%(<-\)\@<!\<chan\>\)\@<=\s\+\%(<-\)\@="
                            
                              " value-ignoring receives in a few contexts
                              syn match goSpaceError display "\%(\%(^\|[={(,;]\)\s*<-\)\@<=\s\+"
                            endif
                            
                            " Extra types commonly seen
                            if s:HighlightExtraTypes()
                              syn match goExtraType /\<bytes\.\%(Buffer\)\>/
                              syn match goExtraType /\<context\.\%(Context\)\>/
                              syn match goExtraType /\<io\.\%(Reader\|ReadSeeker\|ReadWriter\|ReadCloser\|ReadWriteCloser\|Writer\|WriteCloser\|Seeker\)\>/
                              syn match goExtraType /\<reflect\.\%(Kind\|Type\|Value\)\>/
                              syn match goExtraType /\<unsafe\.Pointer\>/
                            endif
                            
                            " Space-tab error
                            if s:HighlightSpaceTabError()
                              syn match goSpaceError display " \+\t"me=e-1
                            endif
                            
                            " Trailing white space error
                            if s:HighlightTrailingWhitespaceError()
                              syn match goSpaceError display excludenl "\s\+$"
                            endif
                            
                            hi def link     goExtraType         Type
                            hi def link     goSpaceError        Error
                            
                            
                            
                            " included from: https://github.com/athom/more-colorful.vim/blob/master/after/syntax/go.vim
                            "
                            " Comments; their contents
                            syn keyword     goTodo              contained NOTE
                            hi def link     goTodo              Todo
                            
                            syn match goVarArgs /\.\.\./
                            
                            " Operators;
                            if s:HighlightOperators()
                              " match single-char operators:          - + % < > ! & | ^ * =
                              " and corresponding two-char operators: -= += %= <= >= != &= |= ^= *= ==
                              syn match goOperator /[-+%<>!&|^*=]=\?/
                              " match / and /=
                              syn match goOperator /\/\%(=\|\ze[^/*]\)/
                              " match two-char operators:               << >> &^
                              " and corresponding three-char operators: <<= >>= &^=
                              syn match goOperator /\%(<<\|>>\|&^\)=\?/
                              " match remaining two-char operators: := && || <- ++ --
                              syn match goOperator /:=\|||\|<-\|++\|--/
                              " match ...
                            
                              hi def link     goPointerOperator   goOperator
                              hi def link     goVarArgs           goOperator
                            endif
                            hi def link     goOperator          Operator
                            
                            " Functions;
                            if s:HighlightFunctions() || s:HighlightFunctionParameters()
                              syn match goDeclaration       /\<func\>/ nextgroup=goReceiver,goFunction,goSimpleParams skipwhite skipnl
                              syn match goReceiverVar       /\w\+\ze\s\+\%(\w\|\*\)/ nextgroup=goPointerOperator,goReceiverType skipwhite skipnl contained
                              syn match goPointerOperator   /\*/ nextgroup=goReceiverType contained skipwhite skipnl
                              syn match goFunction          /\w\+/ nextgroup=goSimpleParams contained skipwhite skipnl
                              syn match goReceiverType      /\w\+/ contained
                              if s:HighlightFunctionParameters()
                                syn match goSimpleParams      /(\%(\w\|\_s\|[*\.\[\],\{\}<>-]\)*)/ contained contains=goParamName,goType nextgroup=goFunctionReturn skipwhite skipnl
                                syn match goFunctionReturn   /(\%(\w\|\_s\|[*\.\[\],\{\}<>-]\)*)/ contained contains=goParamName,goType skipwhite skipnl
                                syn match goParamName        /\w\+\%(\s*,\s*\w\+\)*\ze\s\+\%(\w\|\.\|\*\|\[\)/ contained nextgroup=goParamType skipwhite skipnl
                                syn match goParamType        /\%([^,)]\|\_s\)\+,\?/ contained nextgroup=goParamName skipwhite skipnl
                                                      \ contains=goVarArgs,goType,goSignedInts,goUnsignedInts,goFloats,goComplexes,goDeclType,goBlock
                                hi def link   goReceiverVar    goParamName
                                hi def link   goParamName      Identifier
                              endif
                              syn match goReceiver          /(\s*\w\+\%(\s\+\*\?\s*\w\+\)\?\s*)\ze\s*\w/ contained nextgroup=goFunction contains=goReceiverVar skipwhite skipnl
                            else
                              syn keyword goDeclaration func
                            endif
                            hi def link     goFunction          Function
                            
                            " Function calls;
                            if s:HighlightFunctionCalls()
                              syn match goFunctionCall      /\w\+\ze(/ contains=goBuiltins,goDeclaration
                            endif
                            hi def link     goFunctionCall      Type
                            
                            " Fields;
                            if s:HighlightFields()
                              " 1. Match a sequence of word characters coming after a '.'
                              " 2. Require the following but dont match it: ( \@= see :h E59)
                              "    - The symbols: / - + * %   OR
                              "    - The symbols: [] {} <> )  OR
                              "    - The symbols: \n \r space OR
                              "    - The symbols: , : .
                              " 3. Have the start of highlight (hs) be the start of matched
                              "    pattern (s) offsetted one to the right (+1) (see :h E401)
                              syn match       goField   /\.\w\+\
                                    \%(\%([\/\-\+*%]\)\|\
                                    \%([\[\]{}<\>\)]\)\|\
                                    \%([\!=\^|&]\)\|\
                                    \%([\n\r\ ]\)\|\
                                    \%([,\:.]\)\)\@=/hs=s+1
                            endif
                            hi def link    goField              Identifier
                            
                            " Structs & Interfaces;
                            if s:HighlightTypes()
                              syn match goTypeConstructor      /\<\w\+{\@=/
                              syn match goTypeDecl             /\<type\>/ nextgroup=goTypeName skipwhite skipnl
                              syn match goTypeName             /\w\+/ contained nextgroup=goDeclType skipwhite skipnl
                              syn match goDeclType             /\<\%(interface\|struct\)\>/ skipwhite skipnl
                              hi def link     goReceiverType      Type
                            else
                              syn keyword goDeclType           struct interface
                              syn keyword goDeclaration        type
                            endif
                            hi def link     goTypeConstructor   Type
                            hi def link     goTypeName          Type
                            hi def link     goTypeDecl          Keyword
                            hi def link     goDeclType          Keyword
                            
                            " Variable Assignments
                            if s:HighlightVariableAssignments()
                              syn match goVarAssign /\v[_.[:alnum:]]+(,\s*[_.[:alnum:]]+)*\ze(\s*([-^+|^\/%&]|\*|\<\<|\>\>|\&\^)?\=[^=])/
                              hi def link   goVarAssign         Special
                            endif
                            
                            " Variable Declarations
                            if s:HighlightVariableDeclarations()
                              syn match goVarDefs /\v\w+(,\s*\w+)*\ze(\s*:\=)/
                              hi def link   goVarDefs           Special
                            endif
                            
                            " Build Constraints
                            if s:HighlightBuildConstraints()
                              syn match   goBuildKeyword      display contained "+build\|go:build"
                              " Highlight the known values of GOOS, GOARCH, and other +build options.
                              syn keyword goBuildDirectives   contained
                                    \ android darwin dragonfly freebsd linux nacl netbsd openbsd plan9
                                    \ solaris windows 386 amd64 amd64p32 arm armbe arm64 arm64be ppc64
                                    \ ppc64le mips mipsle mips64 mips64le mips64p32 mips64p32le ppc
                                    \ s390 s390x sparc sparc64 cgo ignore race
                            
                              " Other words in the build directive are build tags not listed above, so
                              " avoid highlighting them as comments by using a matchgroup just for the
                              " start of the comment.
                              " The rs=s+2 option lets the \s*+build portion be part of the inner region
                              " instead of the matchgroup so it will be highlighted as a goBuildKeyword.
                              syn region  goBuildComment      matchgroup=goBuildCommentStart
                                    \ start="//\s*+build\s"rs=s+2 end="$"
                                    \ contains=goBuildKeyword,goBuildDirectives
                              hi def link goBuildCommentStart Comment
                              hi def link goBuildDirectives   Type
                              hi def link goBuildKeyword      PreProc
                            endif
                            
                            if s:HighlightBuildConstraints() || s:FoldEnable('package_comment')
                              " One or more line comments that are followed immediately by a "package"
                              " declaration are treated like package documentation, so these must be
                              " matched as comments to avoid looking like working build constraints.
                              " The he, me, and re options let the "package" itself be highlighted by
                              " the usual rules.
                              exe 'syn region  goPackageComment    start=/\v(\/\/.*\n)+\s*package/'
                                    \ . ' end=/\v\n\s*package/he=e-7,me=e-7,re=e-7'
                                    \ . ' contains=@goCommentGroup,@Spell'
                                    \ . (s:FoldEnable('package_comment') ? ' fold' : '')
                              exe 'syn region  goPackageComment    start=/\v^\s*\/\*.*\n(.*\n)*\s*\*\/\npackage/'
                                    \ . ' end=/\v\*\/\n\s*package/he=e-7,me=e-7,re=e-7'
                                    \ . ' contains=@goCommentGroup,@Spell'
                                    \ . (s:FoldEnable('package_comment') ? ' fold' : '')
                              hi def link goPackageComment    Comment
                            endif
                            
                            " :GoCoverage commands
                            hi def link goCoverageNormalText Comment
                            
                            " Search backwards for a global declaration to start processing the syntax.
                            "syn sync match goSync grouphere NONE /^\(const\|var\|type\|func\)\>/
                            
                            " There's a bug in the implementation of grouphere. For now, use the
                            " following as a more expensive/less precise workaround.
                            syn sync minlines=500
                            
                            let b:current_syntax = "go"
                            
                            let &cpo = s:keepcpo
                            unlet s:keepcpo
                            
                            " vim: sw=2 sts=2 et

SCRIPT  /Users/ryan/.vim/ftplugin/go/gocomplete.vim
Sourced 1 time
Total time:   0.000297
 Self time:   0.000297

count  total (s)   self (s)
    1              0.000017 setlocal omnifunc=gocomplete#Complete

SCRIPT  /Users/ryan/.vim/bundle/vim-go/ftplugin/go.vim
Sourced 1 time
Total time:   0.009152
 Self time:   0.009152

count  total (s)   self (s)
                            " Copyright 2013 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " go.vim: Vim filetype plugin for Go.
                            
    1              0.000012 if exists("b:did_ftplugin")
                              finish
    1              0.000001 endif
    1              0.000004 let b:did_ftplugin = 1
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000008 let s:cpo_save = &cpo
    1              0.000009 set cpo&vim
                            
    1              0.000004 let b:undo_ftplugin = "setl fo< com< cms<"
                                  \ . "| exe 'au! vim-go-buffer * <buffer>'"
                            
    1              0.000003 setlocal formatoptions-=t
                            
    1              0.000003 setlocal comments=s1:/*,mb:*,ex:*/,://
    1              0.000003 setlocal commentstring=//\ %s
                            
    1              0.000004 setlocal noexpandtab
                            
    1              0.008386 compiler go
                            
    1              0.000023 if go#config#CodeCompletionEnabled()
                              " Set autocompletion
    1              0.000010   setlocal omnifunc=go#complete#Complete
    1              0.000001 endif
                            
    1              0.000003 if get(g:, "go_doc_keywordprg_enabled", 1)
                              " keywordprg doesn't allow to use vim commands, override it
    1              0.000013   nnoremap <buffer> <silent> K :GoDoc<cr>
    1              0.000001 endif
                            
    1              0.000003 if get(g:, "go_def_mapping_enabled", 1)
                              " these are default Vim mappings, we're overriding them to make them
                              " useful again for Go source code
    1              0.000004   nnoremap <buffer> <silent> gd :GoDef<cr>
    1              0.000005   nnoremap <buffer> <silent> <C-]> :GoDef<cr>
    1              0.000006   nnoremap <buffer> <silent> <C-LeftMouse> <LeftMouse>:GoDef<cr>
    1              0.000005   nnoremap <buffer> <silent> g<LeftMouse> <LeftMouse>:GoDef<cr>
    1              0.000007   nnoremap <buffer> <silent> <C-w><C-]> :<C-u>call go#def#Jump("split", 0)<CR>
    1              0.000006   nnoremap <buffer> <silent> <C-w>] :<C-u>call go#def#Jump("split", 0)<CR>
    1              0.000006   nnoremap <buffer> <silent> <C-t> :<C-U>call go#def#StackPop(v:count1)<cr>
    1              0.000001 endif
                            
    1              0.000002 if get(g:, "go_textobj_enabled", 1)
    1              0.000006   onoremap <buffer> <silent> af :<c-u>call go#textobj#Function('a')<cr>
    1              0.000004   xnoremap <buffer> <silent> af :<c-u>call go#textobj#Function('a')<cr>
                            
    1              0.000004   onoremap <buffer> <silent> if :<c-u>call go#textobj#Function('i')<cr>
    1              0.000005   xnoremap <buffer> <silent> if :<c-u>call go#textobj#Function('i')<cr>
                            
    1              0.000005   onoremap <buffer> <silent> ac :<c-u>call go#textobj#Comment('a')<cr>
    1              0.000004   xnoremap <buffer> <silent> ac :<c-u>call go#textobj#Comment('a')<cr>
                            
    1              0.000004   onoremap <buffer> <silent> ic :<c-u>call go#textobj#Comment('i')<cr>
    1              0.000004   xnoremap <buffer> <silent> ic :<c-u>call go#textobj#Comment('i')<cr>
                            
                              " Remap ]] and [[ to jump betweeen functions as they are useless in Go
    1              0.000006   nnoremap <buffer> <silent> ]] :<c-u>call go#textobj#FunctionJump('n', 'next')<cr>
    1              0.000006   nnoremap <buffer> <silent> [[ :<c-u>call go#textobj#FunctionJump('n', 'prev')<cr>
                            
    1              0.000005   onoremap <buffer> <silent> ]] :<c-u>call go#textobj#FunctionJump('o', 'next')<cr>
    1              0.000006   onoremap <buffer> <silent> [[ :<c-u>call go#textobj#FunctionJump('o', 'prev')<cr>
                            
    1              0.000005   xnoremap <buffer> <silent> ]] :<c-u>call go#textobj#FunctionJump('v', 'next')<cr>
    1              0.000005   xnoremap <buffer> <silent> [[ :<c-u>call go#textobj#FunctionJump('v', 'prev')<cr>
    1              0.000001 endif
                            
                            " Autocommands
                            " ============================================================================
                            "
    1              0.000002 augroup vim-go-buffer
    1              0.000090   autocmd! * <buffer>
                            
                              " The file is registered (textDocument/DidOpen) with gopls in plugin/go.vim
                              " on the FileType event.
                            
    1              0.000014   if go#util#has_job()
    1              0.000007     autocmd BufWritePost,FileChangedShellPost <buffer> call go#lsp#DidChange(resolve(expand('<afile>:p')))
    1              0.000002     autocmd BufDelete <buffer> call go#lsp#DidClose(resolve(expand('<afile>:p')))
    1              0.000001   endif
                            
                              " send the textDocument/didChange notification when idle. go#lsp#DidChange
                              " will not send an event if the buffer hasn't changed since the last
                              " notification.
    1              0.000004   autocmd CursorHold,CursorHoldI <buffer> call go#lsp#DidChange(resolve(expand('<afile>:p')))
                            
    1              0.000002   autocmd BufEnter,CursorHold <buffer> call go#auto#update_autocmd()
                            
                              " Echo the identifier information when completion is done. Useful to see
                              " the signature of a function, etc...
    1              0.000003   if exists('##CompleteDone')
    1              0.000002     autocmd CompleteDone <buffer> call go#auto#complete_done()
    1              0.000001   endif
                            
    1              0.000003   autocmd BufWritePre <buffer> call go#auto#fmt_autosave()
    1              0.000002   autocmd BufWritePost <buffer> call go#auto#metalinter_autosave()
                            
                              " TODO(bc): autocmd BufWinLeave call go#lsp#DidChange(expand('<afile>:p'))
                            
    1              0.000003   if !has('textprop')
                                "TODO(bc): how to clear sameids and diagnostics when a non-go buffer is
                                " loaded into a window and the previously loaded buffer is still loaded in
                                " another window?
                            
                                " TODO(bc): only clear when the new buffer isn't the old buffer
                            
                                " clear SameIds when the buffer is unloaded from its last window so that
                                " loading another buffer (especially of a different filetype) in the same
                                " window doesn't highlight the most recently matched identifier's positions.
                                autocmd BufWinLeave <buffer> call go#guru#ClearSameIds()
                                " clear SameIds when a new buffer is loaded in the window so that the
                                " previous buffer's highlighting isn't used.
                                autocmd BufWinEnter <buffer> call go#guru#ClearSameIds()
                            
                                " clear diagnostics when the buffer is unloaded from its last window so that
                                " loading another buffer (especially of a different filetype) in the same
                                " window doesn't highlight the previously loaded buffer's diagnostics.
                                autocmd BufWinLeave <buffer> call go#lsp#ClearDiagnosticHighlights()
                                " clear diagnostics when a new buffer is loaded in the window so that the
                                " previous buffer's diagnostics aren't used.
                                "autocmd BufWinEnter <buffer> call go#lsp#ClearDiagnosticHighlights()
    1              0.000002   endif
    1              0.000001 augroup end
                            
                            " restore Vi compatibility settings
    1              0.000017 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /Users/ryan/.vim/bundle/vim-go/compiler/go.vim
Sourced 1 time
Total time:   0.000271
 Self time:   0.000271

count  total (s)   self (s)
                            " Copyright 2013 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " compiler/go.vim: Vim compiler file for Go.
                            
    1              0.000012 if exists("g:current_compiler")
                              finish
    1              0.000001 endif
    1              0.000004 let g:current_compiler = "go"
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000008 let s:cpo_save = &cpo
    1              0.000010 set cpo&vim
                            
    1              0.000005 if exists(":CompilerSet") != 2
                              command -nargs=* CompilerSet setlocal <args>
    1              0.000001 endif
                            
    1              0.000004 let s:save_cpo = &cpo
    1              0.000006 set cpo-=C
    1              0.000028 if filereadable("makefile") || filereadable("Makefile")
                              CompilerSet makeprg=make
    1              0.000001 else
    1              0.000007   CompilerSet makeprg=go\ build
    1              0.000000 endif
                            
                            " Define the patterns that will be recognized by QuickFix when parsing the
                            " output of Go command that use this errorforamt (when called make, cexpr or
                            " lmake, lexpr). This is the global errorformat, however some command might
                            " use a different output, for those we define them directly and modify the
                            " errorformat ourselves. More information at:
                            " http://vimdoc.sourceforge.net/htmldoc/quickfix.html#errorformat
    1              0.000005 CompilerSet errorformat =%-G#\ %.%#                                 " Ignore lines beginning with '#' ('# command-line-arguments' line sometimes appears?)
    1              0.000005 CompilerSet errorformat+=%-G%.%#panic:\ %m                          " Ignore lines containing 'panic: message'
    1              0.000004 CompilerSet errorformat+=%Ecan\'t\ load\ package:\ %m               " Start of multiline error string is 'can\'t load package'
    1              0.000004 CompilerSet errorformat+=%A%\\%%(%[%^:]%\\+:\ %\\)%\\?%f:%l:%c:\ %m " Start of multiline unspecified string is 'filename:linenumber:columnnumber:'
    1              0.000004 CompilerSet errorformat+=%A%\\%%(%[%^:]%\\+:\ %\\)%\\?%f:%l:\ %m    " Start of multiline unspecified string is 'filename:linenumber:'
    1              0.000004 CompilerSet errorformat+=%C%*\\s%m                                  " Continuation of multiline error message is indented
    1              0.000003 CompilerSet errorformat+=%-G%.%#                                    " All lines not matching any of the above patterns are ignored
    1              0.000008 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " restore Vi compatibility settings
    1              0.000006 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /Users/ryan/.vim/bundle/vim-polyglot/compiler/go.vim
Sourced 1 time
Total time:   0.000354
 Self time:   0.000326

count  total (s)   self (s)
    1   0.000054   0.000026 if polyglot#init#is_disabled(expand('<sfile>:p'), 'go', 'compiler/go.vim')
                              finish
    1              0.000000 endif
                            
                            " Copyright 2013 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " compiler/go.vim: Vim compiler file for Go.
                            
    1              0.000003 if exists("g:current_compiler")
    1              0.000001   finish
                            endif
                            let g:current_compiler = "go"
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            if exists(":CompilerSet") != 2
                              command -nargs=* CompilerSet setlocal <args>
                            endif
                            
                            let s:save_cpo = &cpo
                            set cpo-=C
                            if filereadable("makefile") || filereadable("Makefile")
                              CompilerSet makeprg=make
                            else
                              CompilerSet makeprg=go\ build
                            endif
                            
                            " Define the patterns that will be recognized by QuickFix when parsing the
                            " output of Go command that use this errorforamt (when called make, cexpr or
                            " lmake, lexpr). This is the global errorformat, however some command might
                            " use a different output, for those we define them directly and modify the
                            " errorformat ourselves. More information at:
                            " http://vimdoc.sourceforge.net/htmldoc/quickfix.html#errorformat
                            CompilerSet errorformat =%-G#\ %.%#                                 " Ignore lines beginning with '#' ('# command-line-arguments' line sometimes appears?)
                            CompilerSet errorformat+=%-G%.%#panic:\ %m                          " Ignore lines containing 'panic: message'
                            CompilerSet errorformat+=%Ecan\'t\ load\ package:\ %m               " Start of multiline error string is 'can\'t load package'
                            CompilerSet errorformat+=%A%\\%%(%[%^:]%\\+:\ %\\)%\\?%f:%l:%c:\ %m " Start of multiline unspecified string is 'filename:linenumber:columnnumber:'
                            CompilerSet errorformat+=%A%\\%%(%[%^:]%\\+:\ %\\)%\\?%f:%l:\ %m    " Start of multiline unspecified string is 'filename:linenumber:'
                            CompilerSet errorformat+=%C%*\\s%m                                  " Continuation of multiline error message is indented
                            CompilerSet errorformat+=%-G%.%#                                    " All lines not matching any of the above patterns are ignored
                            let &cpo = s:save_cpo
                            unlet s:save_cpo
                            
                            " restore Vi compatibility settings
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /usr/local/Cellar/macvim/9.0.0065/MacVim.app/Contents/Resources/vim/runtime/compiler/go.vim
Sourced 1 time
Total time:   0.000353
 Self time:   0.000353

count  total (s)   self (s)
                            " Vim compiler file
                            " Compiler:	Go
                            " Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
                            " Last Change:	2014 Aug 16
                            
    1              0.000009 if exists('current_compiler')
    1              0.000002   finish
                            endif
                            let current_compiler = 'go'
                            
                            if exists(':CompilerSet') != 2
                              command -nargs=* CompilerSet setlocal <args>
                            endif
                            
                            let s:save_cpo = &cpo
                            set cpo-=C
                            
                            CompilerSet makeprg=go\ build
                            CompilerSet errorformat=
                                \%-G#\ %.%#,
                                \%A%f:%l:%c:\ %m,
                                \%A%f:%l:\ %m,
                                \%C%*\\s%m,
                                \%-G%.%#
                            
                            let &cpo = s:save_cpo
                            unlet s:save_cpo
                            
                            " vim: sw=2 sts=2 et

SCRIPT  /Users/ryan/.vim/bundle/vim-go/ftplugin/go/commands.vim
Sourced 1 time
Total time:   0.000654
 Self time:   0.000603

count  total (s)   self (s)
                            " -- gorename
    1              0.000013 command! -nargs=? -complete=customlist,go#rename#Complete GoRename call go#rename#Rename(<bang>0, <f-args>)
                            
                            " -- guru
                            " do not configure commands that _require_ guru when not in GOPATH mode.
                            "if go#package#InGOPATH()
    1              0.000005   command! -nargs=* -complete=customlist,go#package#Complete GoGuruScope call go#guru#Scope(<f-args>)
    1              0.000005   command! -range=% GoPointsTo call go#guru#PointsTo(<count>)
    1              0.000005   command! -range=% GoWhicherrs call go#guru#Whicherrs(<count>)
    1              0.000004   command! -range=% GoCallees call go#guru#Callees(<count>)
    1              0.000005   command! -range=% GoDescribe call go#guru#Describe(<count>)
    1              0.000004   command! -range=% GoCallstack call go#guru#Callstack(<count>)
    1              0.000004   command! -range=% GoFreevars call go#guru#Freevars(<count>)
    1              0.000004   command! -range=% GoChannelPeers call go#guru#ChannelPeers(<count>)
                            "endif
                            
    1              0.000005 command! -range=% GoImplements call go#implements#Implements(<count>)
    1              0.000006 command! -range=% GoReferrers call go#referrers#Referrers(<count>)
    1              0.000003 command! -range=0 GoSameIds call go#guru#SameIds(1)
    1              0.000004 command! -range=0 GoSameIdsClear call go#guru#ClearSameIds()
    1              0.000003 command! -range=0 GoSameIdsToggle call go#guru#ToggleSameIds()
    1              0.000004 command! -range=0 GoSameIdsAutoToggle call go#guru#AutoToggleSameIds()
                            
                            " -- calls
    1              0.000002 command! -nargs=0 GoCallers call go#calls#Callers()
                            
                            " -- tags
    1              0.000009 command! -nargs=* -range GoAddTags call go#tags#Add(<line1>, <line2>, <count>, <f-args>)
    1              0.000010 command! -nargs=* -range GoRemoveTags call go#tags#Remove(<line1>, <line2>, <count>, <f-args>)
                            
                            " -- mod
    1              0.000004 command! -nargs=0 -range GoModFmt call go#mod#Format()
                            
                            " -- tool
    1              0.000003 command! -nargs=* -complete=customlist,go#tool#ValidFiles GoFiles echo go#tool#Files(<f-args>)
    1              0.000003 command! -nargs=0 GoDeps echo go#tool#Deps()
    1              0.000002 command! -nargs=0 GoInfo call go#tool#Info(1)
    1              0.000004 command! -nargs=0 GoAutoTypeInfoToggle call go#complete#ToggleAutoTypeInfo()
                            
                            " -- cmd
    1              0.000005 command! -nargs=* -bang GoBuild call go#cmd#Build(<bang>0,<f-args>)
    1              0.000005 command! -nargs=? -bang GoBuildTags call go#cmd#BuildTags(<bang>0, <f-args>)
    1              0.000004 command! -nargs=* -bang GoGenerate call go#cmd#Generate(<bang>0,<f-args>)
    1              0.000006 command! -nargs=* -bang -complete=file GoRun call go#cmd#Run(<bang>0,<f-args>)
    1              0.000005 command! -nargs=* -bang GoInstall call go#cmd#Install(<bang>0, <f-args>)
                            
                            " -- test
    1              0.000005 command! -nargs=* -bang GoTest call go#test#Test(<bang>0, 0, <f-args>)
    1              0.000005 command! -nargs=* -bang GoTestFunc call go#test#Func(<bang>0, <f-args>)
    1              0.000006 command! -nargs=* -bang GoTestCompile call go#test#Test(<bang>0, 1, <f-args>)
                            
                            " -- cover
    1              0.000005 command! -nargs=* -bang GoCoverage call go#coverage#Buffer(<bang>0, <f-args>)
    1              0.000003 command! -nargs=* -bang GoCoverageClear call go#coverage#Clear()
    1              0.000005 command! -nargs=* -bang GoCoverageToggle call go#coverage#BufferToggle(<bang>0, <f-args>)
    1              0.000006 command! -nargs=* -bang GoCoverageBrowser call go#coverage#Browser(<bang>0, <f-args>)
                            
                            " -- play
    1              0.000008 command! -nargs=0 -range=% GoPlay call go#play#Share(<count>, <line1>, <line2>)
                            
                            " -- def
    1              0.000003 command! -nargs=* -range GoDef :call go#def#Jump('', 0)
    1              0.000003 command! -nargs=* -range GoDefType :call go#def#Jump('', 1)
    1              0.000003 command! -nargs=? GoDefPop :call go#def#StackPop(<f-args>)
    1              0.000003 command! -nargs=? GoDefStack :call go#def#Stack(<f-args>)
    1              0.000003 command! -nargs=? GoDefStackClear :call go#def#StackClear(<f-args>)
                            
                            " -- doc
    1              0.000005 command! -nargs=* -range -complete=customlist,go#package#Complete GoDoc call go#doc#Open('new', 'split', <f-args>)
    1              0.000003 command! -nargs=* -range -complete=customlist,go#package#Complete GoDocBrowser call go#doc#OpenBrowser(<f-args>)
                            
                            " -- fmt
    1              0.000003 command! -nargs=0 GoFmt call go#fmt#Format(0)
    1              0.000003 command! -nargs=0 GoFmtAutoSaveToggle call go#fmt#ToggleFmtAutoSave()
    1              0.000003 command! -nargs=0 GoImports call go#fmt#Format(1)
                            
                            " -- asmfmt
    1              0.000003 command! -nargs=0 GoAsmFmtAutoSaveToggle call go#asmfmt#ToggleAsmFmtAutoSave()
                            
                            " -- import
    1              0.000005 command! -nargs=? -complete=customlist,go#package#Complete GoDrop call go#import#SwitchImport(0, '', <f-args>, '')
    1              0.000006 command! -nargs=1 -bang -complete=customlist,go#package#Complete GoImport call go#import#SwitchImport(1, '', <f-args>, '<bang>')
    1              0.000006 command! -nargs=* -bang -complete=customlist,go#package#Complete GoImportAs call go#import#SwitchImport(1, <f-args>, '<bang>')
                            
                            " -- linters
    1              0.000008 command! -nargs=* -bang GoMetaLinter call go#lint#Gometa(<bang>0, 0, <f-args>)
    1              0.000004 command! -nargs=0 GoMetaLinterAutoSaveToggle call go#lint#ToggleMetaLinterAutoSave()
    1              0.000005 command! -nargs=* -bang GoLint call go#lint#Golint(<bang>0, <f-args>)
    1              0.000005 command! -nargs=* -bang GoVet call go#lint#Vet(<bang>0, <f-args>)
    1              0.000006 command! -nargs=* -bang -complete=customlist,go#package#Complete GoErrCheck call go#lint#Errcheck(<bang>0, <f-args>)
                            
                            " -- alternate
    1              0.000004 command! -bang GoAlternate call go#alternate#Switch(<bang>0, '')
                            
                            " -- decls
    1              0.000004 command! -nargs=? -complete=file GoDecls call go#decls#Decls(0, <q-args>)
    1              0.000003 command! -nargs=? -complete=dir GoDeclsDir call go#decls#Decls(1, <q-args>)
                            
                            " -- impl
    1              0.000003 command! -nargs=* -complete=customlist,go#impl#Complete GoImpl call go#impl#Impl(<f-args>)
                            
                            " -- template
    1              0.000004 command! -nargs=0 GoTemplateAutoCreateToggle call go#template#ToggleAutoCreate()
                            
                            " -- keyify
    1   0.000069   0.000018 if go#package#InGOPATH()
                              command! -nargs=0 GoKeyify call go#keyify#Keyify()
    1              0.000001 endif
                            
                            " -- fillstruct
    1              0.000003 command! -nargs=0 GoFillStruct call go#fillstruct#FillStruct()
                            
                            " -- debug
    1              0.000004 if !exists(':GoDebugStart')
                              command! -nargs=* -complete=customlist,go#package#Complete GoDebugStart call go#debug#Start('debug', <f-args>)
                              command! -nargs=* -complete=customlist,go#package#Complete GoDebugTest  call go#debug#Start('test', <f-args>)
                              command! -nargs=* GoDebugTestFunc  call go#debug#TestFunc(<f-args>)
                              command! -nargs=1 GoDebugAttach call go#debug#Start('attach', <f-args>)
                              command! -nargs=? GoDebugConnect call go#debug#Start('connect', <f-args>)
                              command! -nargs=? GoDebugBreakpoint call go#debug#Breakpoint(<f-args>)
    1              0.000000 endif
                            
                            " -- issue
    1              0.000003 command! -nargs=0 GoReportGitHubIssue call go#issue#New()
                            
                            " -- iferr
    1              0.000003 command! -nargs=0 GoIfErr call go#iferr#Generate()
                            
                            " -- lsp
    1              0.000004 command! -nargs=+ -complete=dir GoAddWorkspace call go#lsp#AddWorkspaceDirectory(<f-args>)
    1              0.000004 command! -nargs=0 GoLSPDebugBrowser call go#lsp#DebugBrowser()
    1              0.000005 command! -nargs=* -bang GoDiagnostics call go#lint#Diagnostics(<bang>0, <f-args>)
                            
                            " -- term
    1              0.000003 command! GoToggleTermCloseOnExit call go#term#ToggleCloseOnExit()
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /Users/ryan/.vim/bundle/vim-go/ftplugin/go/mappings.vim
Sourced 1 time
Total time:   0.000744
 Self time:   0.000744

count  total (s)   self (s)
                            " go_jump_to_error defines whether we should pass the bang attribute to the
                            " command or not. This is only used for mappings, because the user can't pass
                            " the bang attribute to the plug mappings below. So instead of hardcoding it
                            " as 0 (no '!' attribute) or 1 (with '!' attribute) we pass the user setting,
                            " which by default is enabled. For commands the user has the ability to pass
                            " the '!', such as :GoBuild or :GoBuild!
    1              0.000007 if !exists("g:go_jump_to_error")
                              let g:go_jump_to_error = 1
    1              0.000001 endif
                            
                            " Some handy plug mappings
    1              0.000021 nnoremap <silent> <Plug>(go-run) :<C-u>call go#cmd#Run(!g:go_jump_to_error)<CR>
                            
    1              0.000007 if has("nvim") || has("terminal")
    1              0.000011   nnoremap <silent> <Plug>(go-run-vertical) :<C-u>call go#cmd#RunTerm(!g:go_jump_to_error, 'vsplit', [])<CR>
    1              0.000009   nnoremap <silent> <Plug>(go-run-split) :<C-u>call go#cmd#RunTerm(!g:go_jump_to_error, 'split', [])<CR>
    1              0.000010   nnoremap <silent> <Plug>(go-run-tab) :<C-u>call go#cmd#RunTerm(!g:go_jump_to_error, 'tabe', [])<CR>
    1              0.000001 endif
                            
    1              0.000009 nnoremap <silent> <Plug>(go-build) :<C-u>call go#cmd#Build(!g:go_jump_to_error)<CR>
    1              0.000008 nnoremap <silent> <Plug>(go-generate) :<C-u>call go#cmd#Generate(!g:go_jump_to_error)<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-install) :<C-u>call go#cmd#Install(!g:go_jump_to_error)<CR>
    1              0.000008 nnoremap <silent> <Plug>(go-test) :<C-u>call go#test#Test(!g:go_jump_to_error, 0)<CR>
    1              0.000008 nnoremap <silent> <Plug>(go-test-func) :<C-u>call go#test#Func(!g:go_jump_to_error)<CR>
    1              0.000008 nnoremap <silent> <Plug>(go-test-compile) :<C-u>call go#test#Test(!g:go_jump_to_error, 1)<CR>
                            
    1              0.000008 nnoremap <silent> <Plug>(go-coverage) :<C-u>call go#coverage#Buffer(!g:go_jump_to_error)<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-coverage-clear) :<C-u>call go#coverage#Clear()<CR>
    1              0.000009 nnoremap <silent> <Plug>(go-coverage-toggle) :<C-u>call go#coverage#BufferToggle(!g:go_jump_to_error)<CR>
    1              0.000008 nnoremap <silent> <Plug>(go-coverage-browser) :<C-u>call go#coverage#Browser(!g:go_jump_to_error)<CR>
                            
    1              0.000006 nnoremap <silent> <Plug>(go-files) :<C-u>call go#tool#Files()<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-deps) :<C-u>call go#tool#Deps()<CR>
    1              0.000006 nnoremap <silent> <Plug>(go-info) :<C-u>call go#tool#Info(1)<CR>
    1              0.000010 nnoremap <silent> <Plug>(go-import) :<C-u>call go#import#SwitchImport(1, '', expand('<cword>'), '')<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-imports) :<C-u>call go#fmt#Format(1)<CR>
    1              0.000006 nnoremap <silent> <Plug>(go-fmt) :<C-u>call go#fmt#Format(0)<CR>
                            
    1              0.000008 nnoremap <silent> <Plug>(go-implements) :<C-u>call go#implements#Implements(-1)<CR>
    1              0.000006 nnoremap <silent> <Plug>(go-callees) :<C-u>call go#guru#Callees(-1)<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-callers) :<C-u>call go#calls#Callers()<CR>
    1              0.000006 nnoremap <silent> <Plug>(go-describe) :<C-u>call go#guru#Describe(-1)<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-callstack) :<C-u>call go#guru#Callstack(-1)<CR>
    1              0.000007 xnoremap <silent> <Plug>(go-freevars) :<C-u>call go#guru#Freevars(0)<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-channelpeers) :<C-u>call go#guru#ChannelPeers(-1)<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-referrers) :<C-u>call go#referrers#Referrers(-1)<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-sameids) :<C-u>call go#guru#SameIds(1)<CR>
    1              0.000006 nnoremap <silent> <Plug>(go-pointsto) :<C-u>call go#guru#PointsTo(-1)<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-whicherrs) :<C-u>call go#guru#Whicherrs(-1)<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-sameids-toggle) :<C-u>call go#guru#ToggleSameIds()<CR>
                            
    1              0.000008 nnoremap <silent> <Plug>(go-rename) :<C-u>call go#rename#Rename(!g:go_jump_to_error)<CR>
                            
    1              0.000007 nnoremap <silent> <Plug>(go-decls) :<C-u>call go#decls#Decls(0, '')<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-decls-dir) :<C-u>call go#decls#Decls(1, '')<CR>
                            
    1              0.000007 nnoremap <silent> <Plug>(go-def) :<C-u>call go#def#Jump('', 0)<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-def-vertical) :<C-u>call go#def#Jump("vsplit", 0)<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-def-split) :<C-u>call go#def#Jump("split", 0)<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-def-tab) :<C-u>call go#def#Jump("tab", 0)<CR>
                            
    1              0.000006 nnoremap <silent> <Plug>(go-def-type) :<C-u>call go#def#Jump('', 1)<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-def-type-vertical) :<C-u>call go#def#Jump("vsplit", 1)<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-def-type-split) :<C-u>call go#def#Jump("split", 1)<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-def-type-tab) :<C-u>call go#def#Jump("tab", 1)<CR>
                            
    1              0.000012 nnoremap <silent> <Plug>(go-def-pop) :<C-u>call go#def#StackPop()<CR>
    1              0.000006 nnoremap <silent> <Plug>(go-def-stack) :<C-u>call go#def#Stack()<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-def-stack-clear) :<C-u>call go#def#StackClear()<CR>
                            
    1              0.000007 nnoremap <silent> <Plug>(go-doc) :<C-u>call go#doc#Open("new", "split")<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-doc-tab) :<C-u>call go#doc#Open("tabnew", "tabe")<CR>
    1              0.000008 nnoremap <silent> <Plug>(go-doc-vertical) :<C-u>call go#doc#Open("vnew", "vsplit")<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-doc-split) :<C-u>call go#doc#Open("new", "split")<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-doc-browser) :<C-u>call go#doc#OpenBrowser()<CR>
                            
    1              0.000008 nnoremap <silent> <Plug>(go-metalinter) :<C-u>call go#lint#Gometa(!g:go_jump_to_error, 0)<CR>
    1              0.000007 nnoremap <silent> <Plug>(go-lint) :<C-u>call go#lint#Golint(!g:go_jump_to_error)<CR>
    1              0.000006 nnoremap <silent> <Plug>(go-vet) :<C-u>call go#lint#Vet(!g:go_jump_to_error)<CR>
                            
    1              0.000007 nnoremap <silent> <Plug>(go-alternate-edit) :<C-u>call go#alternate#Switch(0, "edit")<CR>
    1              0.000008 nnoremap <silent> <Plug>(go-alternate-vertical) :<C-u>call go#alternate#Switch(0, "vsplit")<CR>
    1              0.000008 nnoremap <silent> <Plug>(go-alternate-split) :<C-u>call go#alternate#Switch(0, "split")<CR>
                            
    1              0.000007 nnoremap <silent> <Plug>(go-iferr) :<C-u>call go#iferr#Generate()<CR>
                            
    1              0.000008 nnoremap <silent> <Plug>(go-diagnostics) :<C-u>call go#lint#Diagnostics(!g:go_jump_to_error)<CR>
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /Users/ryan/.vim/bundle/vim-go/ftplugin/go/snippets.vim
Sourced 1 time
Total time:   0.000161
 Self time:   0.000161

count  total (s)   self (s)
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000009 let s:cpo_save = &cpo
    1              0.000009 set cpo&vim
                            
    1              0.000004 if exists("g:go_loaded_gosnippets")
    1              0.000002   finish
                            endif
                            let g:go_loaded_gosnippets = 1
                            
                            function! s:GoUltiSnips() abort
                              if get(g:, 'did_plugin_ultisnips') isnot 1
                                return
                              endif
                            
                              if !exists("g:UltiSnipsSnippetDirectories")
                                let g:UltiSnipsSnippetDirectories = ["gosnippets/UltiSnips"]
                              else
                                let g:UltiSnipsSnippetDirectories += ["gosnippets/UltiSnips"]
                              endif
                            endfunction
                            
                            function! s:GoNeosnippet() abort
                              if get(g:, 'loaded_neosnippet') isnot 1
                                return
                              endif
                            
                              let g:neosnippet#enable_snipmate_compatibility = 1
                            
                              let l:gosnippets_dir = globpath(&rtp, 'gosnippets/snippets')
                              if type(g:neosnippet#snippets_directory) == type([])
                                let g:neosnippet#snippets_directory += [l:gosnippets_dir]
                              elseif type(g:neosnippet#snippets_directory) == type("")
                                if strlen(g:neosnippet#snippets_directory) > 0
                                  let g:neosnippet#snippets_directory = g:neosnippet#snippets_directory . "," . l:gosnippets_dir
                                else
                                  let g:neosnippet#snippets_directory = l:gosnippets_dir
                                endif
                              endif
                            endfunction
                            
                            function! s:GoMinisnip() abort
                              if get(g:, 'loaded_minisnip') isnot 1
                                return
                              endif
                            
                              if exists('g:minisnip_dir')
                                let g:minisnip_dir .= go#util#PathListSep() . globpath(&rtp, 'gosnippets/minisnip')
                              else
                                let g:minisnip_dir = globpath(&rtp, 'gosnippets/minisnip')
                              endif
                            endfunction
                            
                            
                            let s:engine = go#config#SnippetEngine()
                            if s:engine is? 'ultisnips'
                              call s:GoUltiSnips()
                            elseif s:engine is? 'neosnippet'
                              call s:GoNeosnippet()
                            elseif s:engine is? 'minisnip'
                              call s:GoMinisnip()
                            endif
                            
                            " restore Vi compatibility settings
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /Users/ryan/.vim/bundle/vim-go/ftplugin/go/tagbar.vim
Sourced 1 time
Total time:   0.012192
 Self time:   0.012192

count  total (s)   self (s)
                            " Check if tagbar is installed under plugins or is directly under rtp
                            " this covers pathogen + Vundle/Bundle
                            "
                            " Also make sure the ctags command exists
                            "
    1              0.009978 if !executable('ctags')
                              finish
    1              0.002075 elseif globpath(&rtp, 'plugin/tagbar.vim') == ""
    1              0.000003   finish
                            endif
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            if !exists("g:go_gotags_bin")
                              let g:go_gotags_bin = "gotags"
                            endif
                            
                            
                            function! s:SetTagbar()
                              let bin_path = go#path#CheckBinPath(g:go_gotags_bin)
                              if empty(bin_path)
                                return
                              endif
                            
                              if !exists("g:tagbar_type_go")
                                let g:tagbar_type_go = {
                                      \ 'ctagstype' : 'go',
                                      \ 'kinds'     : [
                                      \ 'p:package',
                                      \ 'i:imports',
                                      \ 'c:constants',
                                      \ 'v:variables',
                                      \ 't:types',
                                      \ 'n:interfaces',
                                      \ 'w:fields',
                                      \ 'e:embedded',
                                      \ 'm:methods',
                                      \ 'r:constructor',
                                      \ 'f:functions'
                                      \ ],
                                      \ 'sro' : '.',
                                      \ 'kind2scope' : {
                                      \ 't' : 'ctype',
                                      \ 'n' : 'ntype'
                                      \ },
                                      \ 'scope2kind' : {
                                      \ 'ctype' : 't',
                                      \ 'ntype' : 'n'
                                      \ },
                                      \ 'ctagsbin'  : bin_path,
                                      \ 'ctagsargs' : '-sort -silent'
                                      \ }
                              endif
                            endfunction
                            
                            
                            call s:SetTagbar()
                            
                            " restore Vi compatibility settings
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /usr/local/Cellar/macvim/9.0.0065/MacVim.app/Contents/Resources/vim/runtime/ftplugin/go.vim
Sourced 1 time
Total time:   0.000236
 Self time:   0.000236

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	Go
                            " Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
                            " Last Change:	2014 Aug 16
                            
    1              0.000008 if exists('b:did_ftplugin')
    1              0.000002   finish
                            endif
                            let b:did_ftplugin = 1
                            
                            setlocal formatoptions-=t
                            
                            setlocal comments=s1:/*,mb:*,ex:*/,://
                            setlocal commentstring=//\ %s
                            
                            let b:undo_ftplugin = 'setl fo< com< cms<'
                            
                            " vim: sw=2 sts=2 et

SCRIPT  /Users/ryan/.vim/bundle/vim-go/indent/go.vim
Sourced 1 time
Total time:   0.000154
 Self time:   0.000154

count  total (s)   self (s)
                            " Copyright 2011 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " indent/go.vim: Vim indent file for Go.
                            "
                            " TODO:
                            " - function invocations split across lines
                            " - general line splits (line ends in an operator)
                            
    1              0.000006 if exists("b:did_indent")
                              finish
    1              0.000001 endif
    1              0.000003 let b:did_indent = 1
                            
                            " C indentation is too far off useful, mainly due to Go's := operator.
                            " Let's just define our own.
    1              0.000012 setlocal nolisp
    1              0.000002 setlocal autoindent
    1              0.000005 setlocal indentexpr=GoIndent(v:lnum)
    1              0.000003 setlocal indentkeys+=<:>,0=},0=)
                            
    1              0.000003 if exists("*GoIndent")
    1              0.000001   finish
                            endif
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            function! GoIndent(lnum) abort
                              let prevlnum = prevnonblank(a:lnum-1)
                              if prevlnum == 0
                                " top of file
                                return 0
                              endif
                            
                              " grab the previous and current line, stripping comments.
                              let prevl = substitute(getline(prevlnum), '//.*$', '', '')
                              let thisl = substitute(getline(a:lnum), '//.*$', '', '')
                              let previ = indent(prevlnum)
                            
                              let ind = previ
                            
                              for synid in synstack(a:lnum, 1)
                                if synIDattr(synid, 'name') == 'goRawString'
                                  if prevl =~ '\%(\%(:\?=\)\|(\|,\)\s*`[^`]*$'
                                    " previous line started a multi-line raw string
                                    return 0
                                  endif
                                  " return -1 to keep the current indent.
                                  return -1
                                endif
                              endfor
                            
                              if prevl =~ '[({]\s*$'
                                " previous line opened a block
                                let ind += shiftwidth()
                              endif
                              if prevl =~# '^\s*\(case .*\|default\):$'
                                " previous line is part of a switch statement
                                let ind += shiftwidth()
                              endif
                              " TODO: handle if the previous line is a label.
                            
                              if thisl =~ '^\s*[)}]'
                                " this line closed a block
                                let ind -= shiftwidth()
                              endif
                            
                              " Colons are tricky.
                              " We want to outdent if it's part of a switch ("case foo:" or "default:").
                              " We ignore trying to deal with jump labels because (a) they're rare, and
                              " (b) they're hard to disambiguate from a composite literal key.
                              if thisl =~# '^\s*\(case .*\|default\):$'
                                let ind -= shiftwidth()
                              endif
                            
                              return ind
                            endfunction
                            
                            " restore Vi compatibility settings
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /Users/ryan/.vim/bundle/vim-polyglot/indent/go.vim
Sourced 1 time
Total time:   0.000377
 Self time:   0.000352

count  total (s)   self (s)
    1   0.000045   0.000020 if polyglot#init#is_disabled(expand('<sfile>:p'), 'go', 'indent/go.vim')
                              finish
    1              0.000000 endif
                            
                            " Copyright 2011 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " indent/go.vim: Vim indent file for Go.
                            "
                            " TODO:
                            " - function invocations split across lines
                            " - general line splits (line ends in an operator)
                            
    1              0.000003 if exists("b:did_indent")
    1              0.000001   finish
                            endif
                            let b:did_indent = 1
                            
                            " C indentation is too far off useful, mainly due to Go's := operator.
                            " Let's just define our own.
                            setlocal nolisp
                            setlocal autoindent
                            setlocal indentexpr=GoIndent(v:lnum)
                            setlocal indentkeys+=<:>,0=},0=)
                            
                            if exists("*GoIndent")
                              finish
                            endif
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            function! GoIndent(lnum) abort
                              let prevlnum = prevnonblank(a:lnum-1)
                              if prevlnum == 0
                                " top of file
                                return 0
                              endif
                            
                              " grab the previous and current line, stripping comments.
                              let prevl = substitute(getline(prevlnum), '//.*$', '', '')
                              let thisl = substitute(getline(a:lnum), '//.*$', '', '')
                              let previ = indent(prevlnum)
                            
                              let ind = previ
                            
                              for synid in synstack(a:lnum, 1)
                                if synIDattr(synid, 'name') == 'goRawString'
                                  if prevl =~ '\%(\%(:\?=\)\|(\|,\)\s*`[^`]*$'
                                    " previous line started a multi-line raw string
                                    return 0
                                  endif
                                  " return -1 to keep the current indent.
                                  return -1
                                endif
                              endfor
                            
                              if prevl =~ '[({]\s*$'
                                " previous line opened a block
                                let ind += shiftwidth()
                              endif
                              if prevl =~# '^\s*\(case .*\|default\):$'
                                " previous line is part of a switch statement
                                let ind += shiftwidth()
                              endif
                              " TODO: handle if the previous line is a label.
                            
                              if thisl =~ '^\s*[)}]'
                                " this line closed a block
                                let ind -= shiftwidth()
                              endif
                            
                              " Colons are tricky.
                              " We want to outdent if it's part of a switch ("case foo:" or "default:").
                              " We ignore trying to deal with jump labels because (a) they're rare, and
                              " (b) they're hard to disambiguate from a composite literal key.
                              if thisl =~# '^\s*\(case .*\|default\):$'
                                let ind -= shiftwidth()
                              endif
                            
                              return ind
                            endfunction
                            
                            " restore Vi compatibility settings
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /usr/local/Cellar/macvim/9.0.0065/MacVim.app/Contents/Resources/vim/runtime/indent/go.vim
Sourced 1 time
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Go
                            " Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
                            " Last Change:	2017 Jun 13
                            "
                            " TODO:
                            " - function invocations split across lines
                            " - general line splits (line ends in an operator)
                            
    1              0.000005 if exists('b:did_indent')
    1              0.000002   finish
                            endif
                            let b:did_indent = 1
                            
                            " C indentation is too far off useful, mainly due to Go's := operator.
                            " Let's just define our own.
                            setlocal nolisp
                            setlocal autoindent
                            setlocal indentexpr=GoIndent(v:lnum)
                            setlocal indentkeys+=<:>,0=},0=)
                            
                            if exists('*GoIndent')
                              finish
                            endif
                            
                            function! GoIndent(lnum)
                              let l:prevlnum = prevnonblank(a:lnum-1)
                              if l:prevlnum == 0
                                " top of file
                                return 0
                              endif
                            
                              " grab the previous and current line, stripping comments.
                              let l:prevl = substitute(getline(l:prevlnum), '//.*$', '', '')
                              let l:thisl = substitute(getline(a:lnum), '//.*$', '', '')
                              let l:previ = indent(l:prevlnum)
                            
                              let l:ind = l:previ
                            
                              if l:prevl =~ '[({]\s*$'
                                " previous line opened a block
                                let l:ind += shiftwidth()
                              endif
                              if l:prevl =~# '^\s*\(case .*\|default\):$'
                                " previous line is part of a switch statement
                                let l:ind += shiftwidth()
                              endif
                              " TODO: handle if the previous line is a label.
                            
                              if l:thisl =~ '^\s*[)}]'
                                " this line closed a block
                                let l:ind -= shiftwidth()
                              endif
                            
                              " Colons are tricky.
                              " We want to outdent if it's part of a switch ("case foo:" or "default:").
                              " We ignore trying to deal with jump labels because (a) they're rare, and
                              " (b) they're hard to disambiguate from a composite literal key.
                              if l:thisl =~# '^\s*\(case .*\|default\):$'
                                let l:ind -= shiftwidth()
                              endif
                            
                              return l:ind
                            endfunction
                            
                            " vim: sw=2 sts=2 et

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/quickfix.vim:28
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000014   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
    2              0.000002   endif

FUNCTION  go#lsp#DidOpen()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:701
Called 9 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    9              0.000032   if get(b:, 'go_lsp_did_open', 0)
    9              0.000006     return
                              endif
                            
                              let l:fname = fnamemodify(a:fname, ':p')
                              if !isdirectory(fnamemodify(l:fname, ':h'))
                                return
                              endif
                            
                              let l:lsp = s:lspfactory.get()
                            
                              if !has_key(l:lsp.notificationQueue, l:fname)
                                let l:lsp.notificationQueue[l:fname] = []
                              endif
                            
                              call s:ensureWorkspace(fnamemodify(l:fname, ':h'))
                            
                              let l:lsp.fileVersions[l:fname] = getbufvar(l:fname, 'changedtick')
                            
                              let l:msg = go#lsp#message#DidOpen(l:fname, join(go#util#GetLines(), "\n") . "\n", l:lsp.fileVersions[l:fname])
                              let l:state = s:newHandlerState('')
                            
                              " TODO(bc): setting a buffer level variable here assumes that a:fname is the
                              " current buffer. Change to a:fname first before setting it and then change
                              " back to active buffer.
                              let b:go_lsp_did_open = 1
                            
                              return l:lsp.sendMessage(l:msg, l:state)

FUNCTION  go#config#HighlightExtraTypes()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:424
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return get(g:, 'go_highlight_extra_types', 0)

FUNCTION  5()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim:8
Called 4 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    4              0.000013   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  7()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim:17
Called 18 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
   18              0.000061   call add(self._sections, [a:group, a:contents])

FUNCTION  9()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim:25
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000008   call insert(self._sections, [a:group, a:contents], a:position)

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim:66
Called 3 times
Total time:   0.002011
 Self time:   0.000164

count  total (s)   self (s)
   13              0.000021     for Fn in a:list
   13   0.001948   0.000101       let code = call(Fn, a:000)
   13              0.000016       if code != 0
    3              0.000003         return code
   10              0.000001       endif
   10              0.000010     endfor
                                return 0

FUNCTION  <SNR>67_EnableCompletingInCurrentBuffer()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:585
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001   let b:ycm_completing = 1

FUNCTION  <SNR>67_ClearSignatureHelp()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1195
Called 1 time
Total time:   0.000396
 Self time:   0.000065

count  total (s)   self (s)
    1   0.000337   0.000013   if !s:ShouldUseSignatureHelp()
                                return
    1              0.000001   endif
                            
    1   0.000018   0.000011   call s:StopPoller( s:pollers.signature_help )
    1              0.000002   let s:signature_help = s:default_signature_help
    1              0.000033   call py3eval( 'ycm_state.ClearSignatureHelp()' )

FUNCTION  go#config#AutoSameids()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:246
Called 4 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    4              0.000008     return get(g:, 'go_auto_sameids', 0)

FUNCTION  go#auto#metalinter_autosave()
    Defined: ~/.vim/bundle/vim-go/autoload/go/auto.vim:172
Called 1 time
Total time:   0.000014
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000013   0.000008   if !go#config#MetalinterAutosave() || !isdirectory(expand('%:p:h'))
    1              0.000001     return
                              endif
                            
                              " run gometalinter on save
                              call go#lint#Gometa(!g:go_jump_to_error, 1)

FUNCTION  <SNR>52_check_mixed_indent()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/whitespace.vim:15
Called 1 time
Total time:   0.000227
 Self time:   0.000227

count  total (s)   self (s)
    1              0.000004   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    1              0.000001   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
    1              0.000002   elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
    1              0.000001   else
    1              0.000211     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  <SNR>38_Remove_Matches()
    Defined: /usr/local/Cellar/macvim/9.0.0065/MacVim.app/Contents/Resources/vim/runtime/plugin/matchparen.vim:197
Called 2 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    2              0.000011   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
    2              0.000001   endif

FUNCTION  go#config#ListTypeCommands()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:5
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000008   return get(g:, 'go_list_type_commands', {})

FUNCTION  go#config#HighlightVariableAssignments()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:477
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return get(g:, 'go_highlight_variable_assignments', 0)

FUNCTION  go#config#HighlightBuildConstraints()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:461
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000006   return get(g:, 'go_highlight_build_constraints', 0)

FUNCTION  airline#check_mode()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline.vim:146
Called 30 times
Total time:   0.167982
 Self time:   0.002411

count  total (s)   self (s)
   30              0.000106   let context = s:contexts[a:winnr]
                            
   30              0.000096   if get(w:, 'airline_active', 1)
   20              0.000053     let l:m = mode()
   20              0.000036     if l:m ==# "i"
                                  let l:mode = ['insert']
   20              0.000027     elseif l:m ==# "R"
                                  let l:mode = ['replace']
   20              0.000141     elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
   20              0.000022     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
   20              0.000020     elseif l:m ==# "c"
    2              0.000004       let l:mode = ['commandline']
   18              0.000013     else
   18              0.000035       let l:mode = ['normal']
   20              0.000013     endif
   20              0.000083     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   10              0.000004   else
   10              0.000021     let l:mode = ['inactive']
   10              0.000037     let w:airline_current_mode = get(g:airline_mode_map, '__')
   30              0.000016   endif
                            
   30              0.000078   if g:airline_detect_modified && &modified
    9              0.000028     call add(l:mode, 'modified')
   30              0.000019   endif
                            
   30              0.000043   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
   30              0.000015   endif
                            
   30              0.000116   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
   30              0.000013   endif
                            
   30              0.000040   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
   30              0.000011   endif
                            
   30              0.000041   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
   30              0.000015   endif
                            
   30              0.000108   let mode_string = join(l:mode)
   30              0.000094   if get(w:, 'airline_lastmode', '') != mode_string
    5   0.001738   0.000048     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    5   0.163946   0.000065     call airline#highlighter#highlight(l:mode, context.bufnr)
    5              0.000014     let w:airline_lastmode = mode_string
   30              0.000017   endif
                            
   30              0.000029   return ''

FUNCTION  go#util#has_job()
    Defined: ~/.vim/bundle/vim-go/autoload/go/util.vim:64
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005   return has('job') || has('nvim')

FUNCTION  <SNR>67_SetUpCompleteopt()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:555
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
                              " Some plugins (I'm looking at you, vim-notes) change completeopt by for
                              " instance adding 'longest'. This breaks YCM. So we force our settings.
                              " There's no two ways about this: if you want to use YCM then you have to
                              " have these completeopt settings, otherwise YCM won't work at all.
                            
                              " We need menuone in completeopt, otherwise when there's only one candidate
                              " for completion, the menu doesn't show up.
    1              0.000005   set completeopt-=menu
    1              0.000002   set completeopt+=menuone
                            
                              " This is unnecessary with our features. People use this option to insert
                              " the common prefix of all the matches and then add more differentiating chars
                              " so that they can select a more specific match. With our features, they
                              " don't need to insert the prefix; they just type the differentiating chars.
                              " Also, having this option set breaks the plugin.
    1              0.000003   set completeopt-=longest
                            
    1              0.000002   if s:resolve_completions == s:RESOLVE_ON_DEMAND
                                set completeopt+=popuphidden
    1              0.000000   endif
                            
    1              0.000001   if s:force_preview_popup
                                set completeopt+=popup
    1              0.000001   elseif g:ycm_add_preview_to_completeopt
                                set completeopt+=preview
    1              0.000001   endif

FUNCTION  airline#util#append()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim:33
Called 140 times
Total time:   0.001371
 Self time:   0.001371

count  total (s)   self (s)
  140              0.000325   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
  140              0.000077   endif
  140              0.000407   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  140              0.000370   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  6()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim:12
Called 1 time
Total time:   0.000011
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000003   let spc = empty(a:contents) ? '' : g:airline_symbols.space
    1   0.000008   0.000005   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  <SNR>67_DisableOnLargeFile()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:470
Called 103 times
Total time:   0.000551
 Self time:   0.000551

count  total (s)   self (s)
  103              0.000330   if exists( 'b:ycm_largefile' )
  103              0.000128     return b:ycm_largefile
                              endif
                            
                              let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
                              let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
                              if b:ycm_largefile
                                py3 vimsupport.PostVimMessage( 'YouCompleteMe is disabled in this buffer;' + ' the file exceeded the max size (see YCM options).' )
                              endif
                              return b:ycm_largefile

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/themes.vim:31
Called 284 times
Total time:   0.036003
 Self time:   0.002572

count  total (s)   self (s)
  284   0.035904   0.002473   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  go#config#HighlightTypes()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:457
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return get(g:, 'go_highlight_types', 0)

FUNCTION  go#config#Debug()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:199
Called 4 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    4              0.000016   return get(g:, 'go_debug', [])

FUNCTION  go#lsp#DidChange()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:732
Called 8 times
Total time:   0.001119
 Self time:   0.000648

count  total (s)   self (s)
                              " DidChange is called even when fname isn't open in a buffer (e.g. via
                              " go#lsp#Info); don't report the file as open or as having changed when it's
                              " not actually a buffer.
    8              0.000167   if bufnr(a:fname) == -1
                                return
    8              0.000008   endif
                            
    8              0.000070   let l:fname = fnamemodify(a:fname, ':p')
    8              0.000050   if !isdirectory(fnamemodify(l:fname, ':h'))
                                return
    8              0.000006   endif
                            
    8   0.000094   0.000052   call go#lsp#DidOpen(a:fname)
                            
    8   0.000158   0.000044   let l:lsp = s:lspfactory.get()
                            
    8              0.000100   let l:version = getbufvar(l:fname, 'changedtick')
    8              0.000039   if has_key(l:lsp.fileVersions, l:fname) && l:lsp.fileVersions[l:fname] == l:version
    7              0.000003     return
    1              0.000001   endif
    1              0.000003   let l:lsp.fileVersions[l:fname] = l:version
                            
    1   0.000146   0.000028   let l:msg = go#lsp#message#DidChange(l:fname, join(go#util#GetLines(), "\n") . "\n", l:lsp.fileVersions[l:fname])
    1   0.000054   0.000007   let l:state = s:newHandlerState('')
    1   0.000157   0.000007   return l:lsp.sendMessage(l:msg, l:state)

FUNCTION  <SNR>67_StartMessagePoll()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:88
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000002   if s:pollers.receive_messages.id < 0
    1              0.000008     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
    1              0.000001   endif

FUNCTION  airline#extensions#tabline#buffers#get()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/buffers.vim:47
Called 8 times
Total time:   0.012013
 Self time:   0.000343

count  total (s)   self (s)
    8              0.000006   try
    8   0.000739   0.000046     call <sid>map_keys()
                              catch
                                " no-op
    8              0.000008   endtry
    8              0.000024   let cur = bufnr('%')
    8              0.000024   if cur == s:current_bufnr && &columns == s:column_width
    8              0.000042     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
    7              0.000014       return s:current_tabline
    1              0.000001     endif
    1              0.000000   endif
                            
    1   0.000086   0.000007   let b = airline#extensions#tabline#new_builder()
    1              0.000003   let tab_bufs = tabpagebuflist(tabpagenr())
    1              0.000002   let show_buf_label_first = 0
                            
    1              0.000003   if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
    1              0.000001   endif
    1              0.000001   if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers')
    1              0.000000   endif
                            
    1              0.000003   let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
    1              0.000002   let b.overflow_group = 'airline_tabhid'
    1   0.000012   0.000007   let b.buffers = airline#extensions#tabline#buflist#list()
    1              0.000002   if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
    1              0.000001   endif
                            
    1              0.000003   function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
    1              0.000004   if has("tablineat")
                                function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
                                function! b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
    1              0.000001   endif
                            
    1              0.000001   function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. get(s:number_map, a:i+1, '') . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
    1              0.000006   let current_buffer = max([index(b.buffers, cur), 0])
    1              0.000002   let last_buffer = len(b.buffers) - 1
    1   0.000021   0.000005   call b.insert_titles(current_buffer, 0, last_buffer)
                            
    1   0.000008   0.000004   call b.add_section('airline_tabfill', '')
    1   0.000006   0.000002   call b.split()
    1   0.000007   0.000004   call b.add_section('airline_tabfill', '')
    1              0.000001   if !show_buf_label_first
    1   0.000031   0.000008     call airline#extensions#tabline#add_label(b, 'buffers')
    1              0.000000   endif
                            
    1              0.000001   if tabpagenr('$') > 1
                                call b.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
    1              0.000000   endif
                            
    1              0.000001   let s:current_bufnr = cur
    1              0.000002   let s:column_width = &columns
    1   0.010852   0.000009   let s:current_tabline = b.build()
    1              0.000004   let s:current_visible_buffers = copy(b.buffers)
    1              0.000001   if b._right_title <= last_buffer
                                call remove(s:current_visible_buffers, b._right_title, last_buffer)
    1              0.000001   endif
    1              0.000001   if b._left_title > 0
                                call remove(s:current_visible_buffers, 0, b._left_title)
    1              0.000001   endif
    1              0.000001   return s:current_tabline

FUNCTION  go#lsp#Imports()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:1534
Called 1 time
Total time:   0.051866
 Self time:   0.000128

count  total (s)   self (s)
    1              0.000058   let l:fname = expand('%:p')
                              " send the current file so that TextEdits will be relative to the current
                              " state of the buffer.
    1   0.000106   0.000008   call go#lsp#DidChange(l:fname)
                            
    1   0.000014   0.000004   let l:lsp = s:lspfactory.get()
                            
    1   0.000058   0.000006   let l:state = s:newHandlerState('')
    1   0.000028   0.000012   let l:handler = go#promise#New(function('s:handleCodeAction', ['source.organizeImports', ''], l:state), 10000, '')
    1              0.000002   let l:state.handleResult = l:handler.wrapper
    1              0.000001   let l:state.error = l:handler.wrapper
    1              0.000005   let l:state.handleError = function('s:handleCodeActionError', [l:fname], l:state)
    1   0.000128   0.000008   let l:msg = go#lsp#message#CodeActionImports(l:fname)
    1   0.000163   0.000005   call l:lsp.sendMessage(l:msg, l:state)
                            
                              " await the result to avoid any race conditions among autocmds (e.g.
                              " BufWritePre and BufWritePost)
    1   0.051294   0.000010   call l:handler.await()

FUNCTION  go#auto#fmt_autosave()
    Defined: ~/.vim/bundle/vim-go/autoload/go/auto.vim:139
Called 1 time
Total time:   0.106032
 Self time:   0.000174

count  total (s)   self (s)
    1              0.000096   if !(isdirectory(expand('%:p:h')) && resolve(expand('<afile>:p')) == expand('%:p'))
                                return
    1              0.000001   endif
                            
    1   0.000014   0.000008   if !(go#config#FmtAutosave() || go#config#ImportsAutosave())
                                return
    1              0.000001   endif
                            
                              " Order matters when formatting and adjusting imports, because of gopls'
                              " support for gofumpt. Gofumpt formatting will group all imports that look
                              " like a stdlib package (e.g. there's no '.' in the package path) together.
                              " When the local setting is provided, the only way to get the local imports
                              " grouped separately when gofumpt is used to format is to format first and
                              " then organize imports.
                            
    1   0.000030   0.000014   if go#config#FmtAutosave() && !(go#config#ImportsAutosave() && go#config#ImportsMode() == 'goimports')
    1   0.053896   0.000007     call go#fmt#Format(0)
                            
                                " return early when the imports mode is goimports, because there's no need
                                " to format again when goimports was run
    1   0.000030   0.000016     if go#config#FmtCommand() == 'goimports'
                                  return
    1              0.000002     endif
    1              0.000001   endif
                            
    1   0.000008   0.000005   if !go#config#ImportsAutosave()
                                return
    1              0.000001   endif
                            
    1   0.051937   0.000007   call go#fmt#Format(1)

FUNCTION  <SNR>72_NetrwFile()
    Defined: /usr/local/Cellar/macvim/9.0.0065/MacVim.app/Contents/Resources/vim/runtime/autoload/netrw.vim:4091
Called 1 time
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
                            "  "" call Dfunc("s:NetrwFile(fname<".a:fname.">) win#".winnr())
                            "  "" call Decho("g:netrw_keepdir  =".(exists("g:netrw_keepdir")?   g:netrw_keepdir   : 'n/a'),'~'.expand("<slnum>"))
                            "  "" call Decho("g:netrw_cygwin   =".(exists("g:netrw_cygwin")?    g:netrw_cygwin    : 'n/a'),'~'.expand("<slnum>"))
                            "  "" call Decho("g:netrw_liststyle=".(exists("g:netrw_liststyle")? g:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
                            "  "" call Decho("w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
                            
                              " clean up any leading treedepthstring
    1              0.000004   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                               let fname= substitute(a:fname,'^'.s:treedepthstring.'\+','','')
                            "   "" call Decho("clean up any leading treedepthstring: fname<".fname.">",'~'.expand("<slnum>"))
    1              0.000001   else
    1              0.000002    let fname= a:fname
    1              0.000001   endif
                            
    1              0.000001   if g:netrw_keepdir
                               " vim's idea of the current directory possibly may differ from netrw's
    1              0.000002    if !exists("b:netrw_curdir")
                                let b:netrw_curdir= getcwd()
    1              0.000001    endif
                            
    1              0.000005    if !exists("g:netrw_cygwin") && (has("win32") || has("win95") || has("win64") || has("win16"))
                                if fname =~ '^\' || fname =~ '^\a:\'
                                 " windows, but full path given
                                 let ret= fname
                            "     "" call Decho("windows+full path: isdirectory(".fname.")",'~'.expand("<slnum>"))
                                else
                                 " windows, relative path given
                                 let ret= s:ComposePath(b:netrw_curdir,fname)
                            "     "" call Decho("windows+rltv path: isdirectory(".fname.")",'~'.expand("<slnum>"))
                                endif
                            
    1              0.000007    elseif fname =~ '^/'
                                " not windows, full path given
    1              0.000001     let ret= fname
                            "    "" call Decho("unix+full path: isdirectory(".fname.")",'~'.expand("<slnum>"))
                               else
                                " not windows, relative path given
                                let ret= s:ComposePath(b:netrw_curdir,fname)
                            "    "" call Decho("unix+rltv path: isdirectory(".fname.")",'~'.expand("<slnum>"))
    1              0.000000    endif
                              else
                               " vim and netrw agree on the current directory
                               let ret= fname
                            "   "" call Decho("vim and netrw agree on current directory (g:netrw_keepdir=".g:netrw_keepdir.")",'~'.expand("<slnum>"))
                            "   "" call Decho("vim   directory: ".getcwd(),'~'.expand("<slnum>"))
                            "   "" call Decho("netrw directory: ".(exists("b:netrw_curdir")? b:netrw_curdir : 'n/a'),'~'.expand("<slnum>"))
    1              0.000000   endif
                            
                            "  "" call Dret("s:NetrwFile ".ret)
    1              0.000002   return ret

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/netrw.vim:10
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000004   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
    1              0.000000   endif

FUNCTION  go#config#HighlightFormatStrings()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:469
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return get(g:, 'go_highlight_format_strings', 1)

FUNCTION  <SNR>101_listtype()
    Defined: ~/.vim/bundle/vim-go/autoload/go/list.vim:134
Called 2 times
Total time:   0.000032
 Self time:   0.000023

count  total (s)   self (s)
    2   0.000022   0.000013   let listtype = go#config#ListType()
    2              0.000005   if empty(listtype)
    2              0.000003     return a:listtype
                              endif
                            
                              return listtype

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/parts.vim:81
Called 20 times
Total time:   0.000119
 Self time:   0.000119

count  total (s)   self (s)
   20              0.000049   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
   20              0.000010   endif
   20              0.000017   return ''

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/term.vim:6
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000001   if &buftype == 'terminal'
                                let spc = g:airline_symbols.space
                            
                                let name=get(g:airline_mode_map, 't', 't')
                                call a:1.add_section('airline_a', spc.name.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_term', spc.'%f')
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
    1              0.000001   endif

FUNCTION  <SNR>93_debug()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:1327
Called 5 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
    5              0.000022   let l:shouldStart = len(s:log) == 0
    5              0.000024   let s:log = add(s:log, [a:event, a:data])
                            
    5              0.000007   if l:shouldStart
    4              0.000030     call timer_start(10, function('s:debugasync', []))
    5              0.000002   endif

FUNCTION  <SNR>61_hl_group_exists()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim:82
Called 515 times
Total time:   0.005758
 Self time:   0.005758

count  total (s)   self (s)
  515              0.001556   if !hlexists(a:group)
                                return 0
  515              0.002301   elseif empty(synIDattr(hlID(a:group), 'fg'))
   36              0.000029     return 0
  479              0.000237   endif
  479              0.000363   return 1

FUNCTION  go#util#HasDebug()
    Defined: ~/.vim/bundle/vim-go/autoload/go/util.vim:507
Called 4 times
Total time:   0.000056
 Self time:   0.000038

count  total (s)   self (s)
    4   0.000050   0.000032   return index(go#config#Debug(), a:flag) >= 0

FUNCTION  <SNR>72_NetrwHome()
    Defined: /usr/local/Cellar/macvim/9.0.0065/MacVim.app/Contents/Resources/vim/runtime/autoload/netrw.vim:5925
Called 1 time
Total time:   0.000156
 Self time:   0.000096

count  total (s)   self (s)
    1              0.000003   if exists("g:netrw_home")
    1              0.000025    let home= expand(g:netrw_home)
                              else
                               " go to vim plugin home
                               for home in split(&rtp,',') + ['']
                                if isdirectory(s:NetrwFile(home)) && filewritable(s:NetrwFile(home)) | break | endif
                                 let basehome= substitute(home,'[/\\]\.vim$','','')
                                 if isdirectory(s:NetrwFile(basehome)) && filewritable(s:NetrwFile(basehome))
                                 let home= basehome."/.vim"
                                 break
                                endif
                               endfor
                               if home == ""
                                " just pick the first directory
                                let home= substitute(&rtp,',.*$','','')
                               endif
                               if (has("win32") || has("win95") || has("win64") || has("win16"))
                                let home= substitute(home,'/','\\','g')
                               endif
    1              0.000000   endif
                              " insure that the home directory exists
    1   0.000078   0.000018   if g:netrw_dirhistmax > 0 && !isdirectory(s:NetrwFile(home))
                            "   call Decho("insure that the home<".home."> directory exists")
                               if exists("g:netrw_mkdir")
                            "    call Decho("call system(".g:netrw_mkdir." ".s:ShellEscape(s:NetrwFile(home)).")")
                                call system(g:netrw_mkdir." ".s:ShellEscape(s:NetrwFile(home)))
                               else
                            "    call Decho("mkdir(".home.")")
                                call mkdir(home)
                               endif
    1              0.000000   endif
    1              0.000002   let g:netrw_home= home
    1              0.000001   return home

FUNCTION  <SNR>100_wrapper()
    Defined: ~/.vim/bundle/vim-go/autoload/go/promise.vim:27
Called 2 times
Total time:   0.000349
 Self time:   0.000035

count  total (s)   self (s)
    2              0.000002   try
    2   0.000333   0.000019     let self.retval = call(a:fn, a:000)
                              catch
                                let self.retval = substitute(v:exception, '^Vim', '', '')
                                let self.exception = 1
    2              0.000001   endtry
    2              0.000002   return self.retval

FUNCTION  go#config#FoldEnable()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:501
Called 14 times
Total time:   0.000432
 Self time:   0.000314

count  total (s)   self (s)
   14              0.000138   if a:0 > 0
    7              0.000024     return index(go#config#FoldEnable(), a:1) > -1
    7              0.000003   endif
    7              0.000069   return get(g:, 'go_fold_enable', ['block', 'import', 'varconst', 'package_comment'])

FUNCTION  <SNR>70_ExcludeOther()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/buflist.vim:24
Called 4 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    4              0.000031   if (getbufvar(a:nr, 'current_syntax') == 'qf') ||  (a:exclude_preview && getbufvar(a:nr, '&bufhidden') == 'wipe'  && getbufvar(a:nr, '&buftype') == 'nofile')
    4              0.000008     return 1 | endif

FUNCTION  airline#extensions#tabline#buflist#list()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/buflist.vim:31
Called 19 times
Total time:   0.001743
 Self time:   0.001702

count  total (s)   self (s)
   19              0.000060   if exists('s:current_buffer_list')
   17              0.000020     return s:current_buffer_list
    2              0.000002   endif
                            
    2              0.000007   let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
    2              0.000005   let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
    2              0.000005   let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
    2              0.000012   let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
    2              0.000003   let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
   98              0.000073   for nr in list
   96              0.000141     if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                            
                                  " check buffer numbers first
    4              0.000009       if index(exclude_buffers, nr) >= 0
                                    continue
                                    " check paths second
    4              0.000011       elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                    " check other types last
    4   0.000063   0.000022       elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
    4              0.000003       endif
                            
    4              0.000010       call add(buffers, nr)
   96              0.000043     endif
   98              0.000050   endfor
                            
    2              0.000005   let s:current_buffer_list = buffers
    2              0.000002   return buffers

FUNCTION  go#config#HighlightSpaceTabError()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:428
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004   return get(g:, 'go_highlight_space_tab_error', 0)

FUNCTION  go#fmt#Format()
    Defined: ~/.vim/bundle/vim-go/autoload/go/fmt.vim:20
Called 2 times
Total time:   0.105819
 Self time:   0.000085

count  total (s)   self (s)
    2   0.000035   0.000015   let l:bin_name = go#config#FmtCommand()
    2              0.000003   if a:withGoimport == 1
    1   0.000015   0.000005     let l:mode = go#config#ImportsMode()
    1              0.000002     if l:mode == 'gopls'
    1   0.000007   0.000004       if !go#config#GoplsEnabled()
                                    call go#util#EchoError("go_imports_mode is 'gopls', but gopls is disabled")
                                    return
    1              0.000000       endif
    1   0.051880   0.000014       call go#lsp#Imports()
    1              0.000001       return
                                endif
                            
                                let l:bin_name = 'goimports'
    1              0.000001   endif
                            
    1              0.000002   if l:bin_name == 'gopls'
    1   0.000007   0.000004     if !go#config#GoplsEnabled()
                                  call go#util#EchoError("go_fmt_command is 'gopls', but gopls is disabled")
                                  return
    1              0.000000     endif
    1   0.053843   0.000011     call go#lsp#Format()
    1              0.000001     return
                              endif
                            
                              if go#config#FmtExperimental()
                                " Using winsaveview to save/restore cursor state has the problem of
                                " closing folds on save:
                                "   https://github.com/fatih/vim-go/issues/502
                                " One fix is to use mkview instead. Unfortunately, this sometimes causes
                                " other bad side effects:
                                "   https://github.com/fatih/vim-go/issues/728
                                " and still closes all folds if foldlevel>0:
                                "   https://github.com/fatih/vim-go/issues/732
                                let l:curw = {}
                                try
                                  mkview!
                                catch
                                  let l:curw = winsaveview()
                                endtry
                            
                                " save our undo file to be restored after we are done. This is needed to
                                " prevent an additional undo jump due to BufWritePre auto command and also
                                " restore 'redo' history because it's getting being destroyed every
                                " BufWritePre
                                let tmpundofile = tempname()
                                exe 'wundo! ' . tmpundofile
                              else
                                " Save cursor position and many other things.
                                let l:curw = winsaveview()
                              endif
                            
                              " Write current unsaved buffer to a temp file
                              let l:tmpname = tempname() . '.go'
                              call writefile(go#util#GetLines(), l:tmpname)
                              if go#util#IsWin()
                                let l:tmpname = tr(l:tmpname, '\', '/')
                              endif
                            
                              let current_col = col('.')
                              let [l:out, l:err] = go#fmt#run(l:bin_name, l:tmpname, expand('%'))
                              let line_offset = len(readfile(l:tmpname)) - line('$')
                              let l:orig_line = getline('.')
                            
                              if l:err == 0
                                call go#fmt#update_file(l:tmpname, expand('%'))
                              elseif !go#config#FmtFailSilently()
                                let l:errors = s:replace_filename(expand('%'), out)
                                call go#fmt#ShowErrors(l:errors)
                              endif
                            
                              " We didn't use the temp file, so clean up
                              call delete(l:tmpname)
                            
                              if go#config#FmtExperimental()
                                " restore our undo history
                                silent! exe 'rundo ' . tmpundofile
                                call delete(tmpundofile)
                            
                                " Restore our cursor/windows positions, folds, etc.
                                if empty(l:curw)
                                  silent! loadview
                                else
                                  call winrestview(l:curw)
                                endif
                              else
                                " Restore our cursor/windows positions.
                                call winrestview(l:curw)
                              endif
                            
                              " be smart and jump to the line the new statement was added/removed and
                              " adjust the column within the line
                              let l:lineno = line('.') + line_offset
                              call cursor(l:lineno, current_col + (len(getline(l:lineno)) - len(l:orig_line)))
                            
                              " Syntax highlighting breaks less often.
                              syntax sync fromstart

FUNCTION  11()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim:33
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return len(self._sections)

FUNCTION  12()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim:62
Called 5 times
Total time:   0.026093
 Self time:   0.002652

count  total (s)   self (s)
    5              0.000006   let side = 1
    5              0.000005   let line = ''
    5              0.000005   let i = 0
    5              0.000011   let length = len(self._sections)
    5              0.000005   let split = 0
    5              0.000005   let is_empty = 0
    5              0.000006   let prev_group = ''
                            
   33              0.000045   while i < length
   28              0.000068     let section = self._sections[i]
   28              0.000051     let group = section[0]
   28              0.000050     let contents = section[1]
   28              0.000035     let pgroup = prev_group
   28   0.000512   0.000195     let prev_group = airline#builder#get_prev_group(self._sections, i)
   28              0.000071     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
   28              0.000085     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
   28              0.000083     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
   28              0.000017     endif
   28              0.000025     if is_empty
                                  let prev_group = pgroup
   28              0.000010     endif
   28   0.000440   0.000199     let is_empty = s:section_is_empty(self, contents)
                            
   28              0.000022     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
   28              0.000012     endif
                            
   28              0.000032     if group == ''
                                  let line .= contents
   28              0.000030     elseif group == '|'
    5              0.000005       let side = 0
    5              0.000008       let line .= contents
    5              0.000005       let split = 1
   23              0.000012     else
   23              0.000028       if prev_group == ''
    5              0.000013         let line .= '%#'.group.'#'
   18              0.000012       elseif split
    5              0.000004         if !is_empty
    5   0.005688   0.000055           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    5              0.000004         endif
    5              0.000006         let split = 0
   13              0.000005       else
   13              0.000011         if !is_empty
   13   0.016479   0.000102           let line .= s:get_seperator(self, prev_group, group, side)
   13              0.000008         endif
   23              0.000012       endif
   23   0.001096   0.000223       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   28              0.000014     endif
                            
   28              0.000047     let i = i + 1
   33              0.000035   endwhile
                            
    5              0.000006   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
    2              0.000068     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    5              0.000003   endif
    5              0.000006   return line

FUNCTION  13()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/builder.vim:18
Called 1 time
Total time:   0.000016
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000002   let self._first_title = a:first " lowest index
    1              0.000002   let self._last_title = a:last " highest index
    1              0.000002   let self._left_title = a:current " next index to add on the left
    1              0.000001   let self._right_title = a:current + 1 " next index to add on the right
    1   0.000007   0.000004   let self._left_position = self.get_position() " left end of titles
    1              0.000002   let self._right_position = self._left_position " right end of the titles

FUNCTION  14()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/builder.vim:41
Called 2 times
Total time:   0.000768
 Self time:   0.000088

count  total (s)   self (s)
    2   0.000241   0.000009   let title = self.get_title(a:index)
    2   0.000454   0.000015   let title_size = s:tabline_evaluated_length(title) + a:sep_size
    2              0.000004   if a:force || self._remaining_space >= title_size
    2              0.000003     let pos = a:pos
    2              0.000004     if has_key(self, "get_pretitle")
                                  call self.insert_raw(self.get_pretitle(a:index), pos)
                                  let self._right_position += 1
                                  let pos += 1
    2              0.000001     endif
                            
    2   0.000019   0.000010     call self.insert_section(a:group, title, pos)
    2              0.000004     let self._right_position += 1
    2              0.000002     let pos += 1
                            
    2              0.000004     if has_key(self, "get_posttitle")
                                  call self.insert_raw(self.get_posttitle(a:index), pos)
                                  let self._right_position += 1
                                  let pos += 1
    2              0.000001     endif
                            
    2              0.000002     let self._remaining_space -= title_size
    2              0.000001     return 1
                              endif
                              return 0

FUNCTION  15()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/builder.vim:96
Called 1 time
Total time:   0.010843
 Self time:   0.000240

count  total (s)   self (s)
    1              0.000003   if has_key(self, '_left_position') && self._first_title <= self._last_title
    1   0.003246   0.000013     let self._remaining_space = &columns - s:tabline_evaluated_length(self._build())
                            
    1              0.000003     let center_active = get(g:, 'airline#extensions#tabline#center_active', 0)
                            
    1   0.000059   0.000007     let sep_size = s:tabline_evaluated_length(self._context.left_sep)
    1   0.000053   0.000007     let alt_sep_size = s:tabline_evaluated_length(self._context.left_alt_sep)
                            
    1   0.000019   0.000007     let outer_left_group = airline#builder#get_prev_group(self._sections, self._left_position)
    1   0.000030   0.000009     let outer_right_group = airline#builder#get_next_group(self._sections, self._right_position)
                            
    1              0.000005     let overflow_marker = get(g:, 'airline#extensions#tabline#overflow_marker', g:airline_symbols.ellipsis)
    1   0.000056   0.000007     let overflow_marker_size = s:tabline_evaluated_length(overflow_marker)
                                " Allow space for the markers before we begin filling in titles.
    1              0.000002     if self._left_title > self._first_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_left_group, sep_size, alt_sep_size)
    1              0.000000     endif
    1              0.000002     if self._left_title < self._last_title
    1   0.000306   0.000009       let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_right_group, sep_size, alt_sep_size)
    1              0.000001     endif
                            
                                " Add the current title
    1   0.000059   0.000006     let group = self.get_group(self._left_title)
    1              0.000001     if self._left_title == self._first_title
    1   0.000035   0.000008       let sep_change = s:get_separator_change(group, "", outer_left_group, sep_size, alt_sep_size)
                                else
                                  let sep_change = s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
    1              0.000001     endif
    1              0.000001     if self._left_title == self._last_title
                                  let sep_change += s:get_separator_change(group, "", outer_right_group, sep_size, alt_sep_size)
    1              0.000001     else
    1   0.000295   0.000007       let sep_change += s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
    1              0.000001     endif
    1              0.000001     let left_group = group
    1              0.000001     let right_group = group
    1   0.000415   0.000008     let self._left_title -= self.try_insert_title(self._left_title, group, self._left_position, sep_change, 1)
                            
    1              0.000003     if get(g:, 'airline#extensions#tabline#current_first', 0)
                                  " always have current title first
                                  let self._left_position += 1
    1              0.000000     endif
                            
    1              0.000003     if !center_active && self._right_title <= self._last_title
                                  " Add the title to the right
    1   0.000046   0.000004       let group = self.get_group(self._right_title)
    1              0.000002       if self._right_title == self._last_title
    1   0.000807   0.000011         let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                  else
                                    let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
    1              0.000001       endif
    1              0.000002       let right_group = group
    1   0.000366   0.000005       let self._right_title += self.try_insert_title(self._right_title, group, self._right_position, sep_change, 1)
    1              0.000001     endif
                            
    1              0.000002     while self._remaining_space > 0
    1              0.000002       let done = 0
    1              0.000001       if self._left_title >= self._first_title
                                    " Insert next title to the left
                                    let group = self.get_group(self._left_title)
                                    if self._left_title == self._first_title
                                      let sep_change = s:get_separator_change_with_end(group, left_group, outer_left_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, left_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let left_group = group
                                    let done = self.try_insert_title(self._left_title, group, self._left_position, sep_change, 0)
                                    let self._left_title -= done
    1              0.000000       endif
                                  " If center_active is set, this |if| operates as an independent |if|,
                                  " otherwise as an |elif|.
    1              0.000003       if self._right_title <= self._last_title && (center_active || !done)
                                    " Insert next title to the right
                                    let group = self.get_group(self._right_title)
                                    if self._right_title == self._last_title
                                      let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let right_group = group
                                    let done = self.try_insert_title(self._right_title, group, self._right_position, sep_change, 0)
                                    let self._right_title += done
    1              0.000001       endif
    1              0.000001       if !done
    1              0.000001         break
                                  endif
    1              0.000002     endwhile
                            
    1              0.000001     if self._left_title >= self._first_title
                                  if get(g:, 'airline#extensions#tabline#current_first', 0)
                                    let self._left_position -= 1
                                  endif
                                  call self.insert_section(self.overflow_group, overflow_marker, self._left_position)
                                  let self._right_position += 1
    1              0.000001     endif
                            
    1              0.000001     if self._right_title <= self._last_title
                                  call self.insert_section(self.overflow_group, overflow_marker, self._right_position)
    1              0.000000     endif
    1              0.000001   endif
                            
    1   0.004925   0.000006   return self._build()

FUNCTION  <SNR>93_handleFormat()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:1647
Called 1 time
Total time:   0.000303
 Self time:   0.000022

count  total (s)   self (s)
    1   0.000075   0.000007   call go#fmt#CleanErrors()
                            
    1              0.000003   if type(a:msg) is type('')
                                call self.handleError(a:msg)
                                return
    1              0.000001   endif
    1   0.000222   0.000009   call s:applyTextEdits(bufnr(''), a:msg)

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim:195
Called 34 times
Total time:   0.017714
 Self time:   0.000474

count  total (s)   self (s)
   34              0.000163   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   34   0.017537   0.000297   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  <SNR>67_EnableAutoHover()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:651
Called 1 time
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
    1              0.000003   if g:ycm_auto_hover ==# 'CursorHold' && s:enable_hover
    1              0.000002     augroup YcmBufHover
    1              0.000081       autocmd! * <buffer>
    1              0.000004       autocmd CursorHold <buffer> call s:Hover()
    1              0.000001     augroup END
    1              0.000001   endif

FUNCTION  go#config#CodeCompletionEnabled()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:512
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006   return get(g:, "go_code_completion_enabled", 1)

FUNCTION  airline#extensions#po#apply()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/po.vim:15
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000002   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
    1              0.000000   endif

FUNCTION  <SNR>64_section_is_empty()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim:184
Called 28 times
Total time:   0.000241
 Self time:   0.000241

count  total (s)   self (s)
   28              0.000031   let start=1
                            
                              " do not check for inactive windows or the tabline
   28              0.000041   if a:self._context.active == 0
   10              0.000008     return 0
   18              0.000044   elseif get(a:self._context, 'tabline', 0)
   10              0.000010     return 0
    8              0.000001   endif
                            
                              " only check, if airline#skip_empty_sections == 1
    8              0.000019   if get(g:, 'airline_skip_empty_sections', 0) == 0
    8              0.000005     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  20()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:9
Called 10 times
Total time:   0.000134
 Self time:   0.000134

count  total (s)   self (s)
   10              0.000077   if empty(get(self, 'current', {})) || empty(get(self.current, 'job', {}))
                                let self.current = s:newlsp()
   10              0.000005   endif
                            
   10              0.000016   return self.current

FUNCTION  22()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:82
Called 2 times
Total time:   0.000314
 Self time:   0.000279

count  total (s)   self (s)
    2              0.000007     let l:responses = []
    2              0.000003     let l:rest = a:data
                            
    4              0.000007     while 1
                                  " Look for the end of the HTTP headers
    4              0.000030       let l:body_start_idx = matchend(l:rest, "\r\n\r\n")
                            
    4              0.000007       if l:body_start_idx < 0
                                    " incomplete header
    2              0.000001         break
    2              0.000002       endif
                            
                                  " Parse the Content-Length header.
    2              0.000012       let l:header = l:rest[:l:body_start_idx - 4]
    2              0.000024       let l:length_match = matchlist(   l:header,   '\vContent-Length: *(\d+)')
                            
    2              0.000006       if empty(l:length_match)
                                    " TODO(bc): shutdown gopls?
                                    throw "invalid JSON-RPC header:\n" . l:header
    2              0.000002       endif
                            
                                  " get the start of the rest
    2              0.000011       let l:next_start_idx = l:body_start_idx + str2nr(l:length_match[1])
                            
    2              0.000006       if len(l:rest) < l:next_start_idx
                                    " incomplete response body
                                    break
    2              0.000002       endif
                            
    2   0.000056   0.000021       call s:debug('received', l:rest[:l:next_start_idx - 1])
                            
    2              0.000007       let l:body = l:rest[l:body_start_idx : l:next_start_idx - 1]
    2              0.000005       let l:rest = l:rest[l:next_start_idx :]
                            
    2              0.000002       try
                                    " add the json body to the list.
    2              0.000017         call add(l:responses, json_decode(l:body))
                                  catch
                                    " TODO(bc): log the message and/or show an error message.
    2              0.000002       finally
                                    " intentionally left blank.
    2              0.000002       endtry
    4              0.000009     endwhile
                            
    2              0.000006     return [l:rest, l:responses]

FUNCTION  25()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:181
Called 2 times
Total time:   0.000492
 Self time:   0.000136

count  total (s)   self (s)
    2              0.000010     if has_key(a:resp, 'id') && has_key(self.handlers, a:resp.id)
    2              0.000002       try
    2              0.000006         let l:handler = self.handlers[a:resp.id]
                            
    2              0.000008         let l:winid = win_getid(winnr())
                                    " Always set the active window to the window that was active when
                                    " the request was sent. Among other things, this makes sure that
                                    " the correct window's location list will be populated when the
                                    " list type is 'location' and the user has moved windows since
                                    " sending the request.
    2              0.000008         call win_gotoid(l:handler.winid)
                            
    2              0.000004         if has_key(a:resp, 'error')
                                      call l:handler.requestComplete(0)
                                      if has_key(l:handler, 'error')
                                        call call(l:handler.error, [a:resp.error.message])
                                      else
                                        call go#util#EchoError(a:resp.error.message)
                                      endif
                                      call win_gotoid(l:winid)
                                      return
    2              0.000000         endif
    2   0.000026   0.000019         call l:handler.requestComplete(1)
                            
    2              0.000004         let l:winidBeforeHandler = l:handler.winid
    2   0.000367   0.000018         call call(l:handler.handleResult, [a:resp.result])
                            
                                    " change the window back to the window that was active when
                                    " starting to handle the message _only_ if the handler didn't
                                    " update the winid, so that handlers can set the winid if needed
                                    " (e.g. :GoDef).
    2              0.000003         if l:handler.winid == l:winidBeforeHandler
    2              0.000005           call win_gotoid(l:winid)
    2              0.000001         endif
    2              0.000001       finally
    2              0.000007         call remove(self.handlers, a:resp.id)
    2              0.000002       endtry
    2              0.000002     endif

FUNCTION  <SNR>20_LoadIndent()
    Defined: /usr/local/Cellar/macvim/9.0.0065/MacVim.app/Contents/Resources/vim/runtime/indent.vim:15
Called 1 time
Total time:   0.002316
 Self time:   0.001630

count  total (s)   self (s)
    1              0.000002   if exists("b:undo_indent")
                                legacy exe b:undo_indent
                                unlet! b:undo_indent b:did_indent
                              endif
    1              0.000001   var s = expand("<amatch>")
    1              0.000000   if s != ""
    1              0.000002     if exists("b:did_indent")
    1              0.000000       unlet b:did_indent
    1              0.000000     endif
                            
                                # When there is a dot it is used to separate filetype names.  Thus for
                                # "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    1              0.000004     for name in split(s, '\.')
    1   0.002263   0.001577       exe 'runtime! indent/' .. name .. '.vim'
    1              0.000000     endfor
    1              0.000000   endif

FUNCTION  <SNR>67_ReceiveMessages()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:97
Called 94 times
Total time:   0.025568
 Self time:   0.015118

count  total (s)   self (s)
   94              0.001155   let poll_again = v:false
   94   0.011709   0.001259   if s:AllowedToCompleteInCurrentBuffer()
   94              0.010780     let poll_again = py3eval( 'ycm_state.OnPeriodicTick()' )
   94              0.000121   endif
                            
   94              0.000128   if poll_again
   94              0.001030     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
                              else
                                " Don't poll again until we open another buffer
                                let s:pollers.receive_messages.id = -1
   94              0.000056   endif

FUNCTION  <SNR>67_HasAnyKey()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:485
Called 103 times
Total time:   0.001652
 Self time:   0.001652

count  total (s)   self (s)
  206              0.000438   for key in a:keys
  103              0.000281     if has_key( a:dict, key )
                                  return 1
  103              0.000069     endif
  206              0.000172   endfor
  103              0.000104   return 0

FUNCTION  go#promise#New()
    Defined: ~/.vim/bundle/vim-go/autoload/go/promise.vim:16
Called 2 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    2              0.000005   let l:state = {}
                            
                              " explicitly bind to state so that within l:promise's methods, self will
                              " always refer to state. See :help Partial for more information.
    2              0.000024   return { 'wrapper': function('s:wrapper', [a:fn, a:default], l:state), 'await': function('s:await', [a:timeout, a:default], l:state), }

FUNCTION  <SNR>67_Hover()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1412
Called 4 times
Total time:   0.002089
 Self time:   0.000475

count  total (s)   self (s)
    4              0.000296     if !py3eval( 'ycm_state.NativeFiletypeCompletionUsable()' )
                                  " Cancel the autocommand if it happens to have been set
                                  call s:DisableAutoHover()
                                  return
    4              0.000003     endif
                            
    4              0.000011     if !has_key( b:, 'ycm_hover' )
                                  let cmds = youcompleteme#GetDefinedSubcommands()
                                  if index( cmds, 'GetHover' ) >= 0
                                    let b:ycm_hover = { 'command': 'GetHover', 'syntax': 'markdown', }
                                  elseif index( cmds, 'GetDoc' ) >= 0
                                    let b:ycm_hover = { 'command': 'GetDoc', 'syntax': '', }
                                  elseif index( cmds, 'GetType' ) >= 0
                                    let b:ycm_hover = { 'command': 'GetType', 'syntax': &syntax, }
                                  else
                                    let b:ycm_hover = {}
                                  endif
    4              0.000004     endif
                            
    4              0.000008     if empty( b:ycm_hover )
                                  return
    4              0.000002     endif
                            
    4   0.001674   0.000060     call youcompleteme#GetCommandResponseAsync( function( 's:ShowHoverResult' ), b:ycm_hover.command )

FUNCTION  go#config#FmtCommand()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:361
Called 3 times
Total time:   0.000034
 Self time:   0.000025

count  total (s)   self (s)
    3   0.000032   0.000023   return get(g:, "go_fmt_command", go#config#GoplsEnabled() ? 'gopls' : 'gofmt')

FUNCTION  <SNR>93_start()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:582
Called 3 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    3              0.000013   let self.started_at = reltime()
    3              0.000006   if self.statustype == ''
    3              0.000002     return
                              endif
                              let status = { 'desc': 'current status', 'type': self.statustype, 'state': "started", }
                            
                              call go#statusline#Update(self.jobdir, status)

FUNCTION  31()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:342
Called 3 times
Total time:   0.000549
 Self time:   0.000222

count  total (s)   self (s)
    3              0.000006     if !self.last_request_id
                                  let l:wd = go#util#ModuleRoot()
                                  if l:wd == -1
                                    call go#util#EchoError('could not determine appropriate working directory for gopls')
                                    return -1
                                  endif
                            
                                  if l:wd == ''
                                    let l:wd = getcwd()
                                  endif
                                  let self.wd = l:wd
                            
                                  if go#config#EchoCommandInfo()
                                    call go#util#EchoProgress("initializing gopls")
                                  endif
                            
                                  let l:status = { 'desc': '', 'type': 'gopls', 'state': 'initializing', }
                                  call go#statusline#Update(l:wd, l:status)
                            
                                  let self.workspaceDirectories = add(self.workspaceDirectories, l:wd)
                                  let l:msg = self.newMessage(go#lsp#message#Initialize(l:wd))
                            
                                  let l:state = s:newHandlerState('')
                                  let l:state.handleResult = funcref('self.handleInitializeResult', [], l:self)
                            
                                  let self.handlers[l:msg.id] = l:state
                            
                                  call l:state.start()
                                  call self.write(l:msg)
    3              0.000002     endif
                            
    3              0.000004     if !self.ready
                                  call add(self.queue, {'data': a:data, 'handler': a:handler})
                                  return
    3              0.000003     endif
                            
    3   0.000074   0.000018     let l:msg = self.newMessage(a:data)
    3              0.000006     if has_key(l:msg, 'id')
    2              0.000010       let self.handlers[l:msg.id] = a:handler
    3              0.000002     endif
                            
    3   0.000043   0.000018     call a:handler.start()
    3   0.000262   0.000016     call self.write(l:msg)

FUNCTION  32()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:394
Called 3 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    3              0.000014     let l:msg = { 'method': a:data.method, 'jsonrpc': '2.0', }
                            
    3              0.000003     if !a:data.notification
    2              0.000005       let self.last_request_id += 1
    2              0.000004       let l:msg.id = self.last_request_id
    3              0.000001     endif
                            
    3              0.000007     if has_key(a:data, 'params')
    3              0.000006       let l:msg.params = a:data.params
    3              0.000002     endif
                            
    3              0.000003     return l:msg

FUNCTION  34()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:422
Called 3 times
Total time:   0.000246
 Self time:   0.000184

count  total (s)   self (s)
    3              0.000014     if empty(get(self, 'job', {}))
                                  return
    3              0.000003     endif
                            
    3              0.000028     let l:body = json_encode(a:msg)
    3              0.000020     let l:data = 'Content-Length: ' . strlen(l:body) . "\r\n\r\n" . l:body
                            
    3   0.000090   0.000028     call s:debug('sent', l:data)
                            
    3              0.000014     if has('nvim')
                                  call chansend(self.job, l:data)
                                  return
    3              0.000000     endif
                            
    3              0.000003     try
    3              0.000035       call ch_sendraw(self.job, l:data)
                                catch
                                  call go#util#EchoError(printf('could not send message: %s', v:exception))
    3              0.000003     endtry

FUNCTION  <SNR>67_OnVimLeave()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:596
Called 1 time
Total time:   0.004702
 Self time:   0.004671

count  total (s)   self (s)
                              " Workaround a NeoVim issue - not shutting down timers correctly
                              " https://github.com/neovim/neovim/issues/6840
    8              0.000017   for poller in values( s:pollers )
    7   0.000073   0.000042     call s:StopPoller( poller )
    8              0.000008   endfor
    1              0.004596   py3 ycm_state.OnVimLeave()

FUNCTION  <SNR>95_position()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp/message.vim:406
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000006   return {'line': a:line, 'character': a:col}

FUNCTION  go#config#HighlightFunctions()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:440
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return get(g:, 'go_highlight_functions', 0)

FUNCTION  go#path#ToURI()
    Defined: ~/.vim/bundle/vim-go/autoload/go/path.vim:158
Called 3 times
Total time:   0.000242
 Self time:   0.000111

count  total (s)   self (s)
    3   0.000042   0.000029   let l:absolute = !go#util#IsWin() && a:path[0] is# '/'
    3              0.000005   let l:prefix = ''
    3              0.000003   let l:path = a:path
                            
    3   0.000023   0.000015   if go#util#IsWin() && l:path[1:2] is# ':\'
                                let l:absolute = 1
                                let l:prefix = '/' . l:path[0:1]
                                let l:path = l:path[2:]
    3              0.000003   endif
                            
    3   0.000145   0.000035   return substitute(   (l:absolute ? 'file://' : '') . l:prefix . go#uri#EncodePath(l:path),   '\\',   '/',   'g',)

FUNCTION  airline#extensions#tabline#get_buffer_name()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline.vim:162
Called 18 times
Total time:   0.004125
 Self time:   0.000449

count  total (s)   self (s)
   18   0.001929   0.000191   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
   18              0.000058   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
   18   0.002128   0.000190   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  <SNR>58_map_keys()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/buffers.vim:182
Called 8 times
Total time:   0.000693
 Self time:   0.000693

count  total (s)   self (s)
    8              0.000024   if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
    8              0.000117     noremap <silent> <Plug>AirlineSelectTab1 :call <SID>select_tab(0)<CR>
    8              0.000060     noremap <silent> <Plug>AirlineSelectTab2 :call <SID>select_tab(1)<CR>
    8              0.000053     noremap <silent> <Plug>AirlineSelectTab3 :call <SID>select_tab(2)<CR>
    8              0.000050     noremap <silent> <Plug>AirlineSelectTab4 :call <SID>select_tab(3)<CR>
    8              0.000049     noremap <silent> <Plug>AirlineSelectTab5 :call <SID>select_tab(4)<CR>
    8              0.000049     noremap <silent> <Plug>AirlineSelectTab6 :call <SID>select_tab(5)<CR>
    8              0.000048     noremap <silent> <Plug>AirlineSelectTab7 :call <SID>select_tab(6)<CR>
    8              0.000050     noremap <silent> <Plug>AirlineSelectTab8 :call <SID>select_tab(7)<CR>
    8              0.000049     noremap <silent> <Plug>AirlineSelectTab9 :call <SID>select_tab(8)<CR>
    8              0.000063     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
    8              0.000056     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
    8              0.000006   endif

FUNCTION  airline#extensions#tabline#new_builder()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline.vim:168
Called 1 time
Total time:   0.000079
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000011   let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
    1              0.000002   if get(g:, 'airline_powerline_fonts', 0)
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
    1              0.000001   else
    1              0.000004     let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
    1              0.000003     let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
    1              0.000001   endif
                            
    1   0.000050   0.000013   return airline#extensions#tabline#builder#new(builder_context)

FUNCTION  <SNR>38_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/macvim/9.0.0065/MacVim.app/Contents/Resources/vim/runtime/plugin/matchparen.vim:40
Called 2 times
Total time:   0.000196
 Self time:   0.000173

count  total (s)   self (s)
                              " Remove any previous match.
    2   0.000038   0.000015   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    2              0.000011   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
    2              0.000001   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    2              0.000007   let c_lnum = line('.')
    2              0.000005   let c_col = col('.')
    2              0.000002   let before = 0
                            
    2              0.000005   let text = getline(c_lnum)
    2              0.000036   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    2              0.000005   if empty(matches)
                                let [c_before, c] = ['', '']
    2              0.000002   else
    2              0.000010     let [c_before, c] = matches[1:2]
    2              0.000001   endif
    2              0.000025   let plist = split(&matchpairs, '.\zs[:,]')
    2              0.000006   let i = index(plist, c)
    2              0.000003   if i < 0
                                " not found, in Insert mode try character before the cursor
    2              0.000008     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
    2              0.000000     endif
    2              0.000002     if i < 0
                                  " not found, nothing to do
    2              0.000002       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>72_NetrwBookHistSave()
    Defined: /usr/local/Cellar/macvim/9.0.0065/MacVim.app/Contents/Resources/vim/runtime/autoload/netrw.vim:3700
Called 1 time
Total time:   0.080215
 Self time:   0.018315

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwBookHistSave() dirhistmax=".g:netrw_dirhistmax." dirhistcnt=".g:netrw_dirhistcnt)
    1              0.000009   if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
                            "   call Dret("s:NetrwBookHistSave : nothing saved (dirhistmax=".g:netrw_dirhistmax.")")
                               return
    1              0.000001   endif
                            
    1   0.000172   0.000016   let savefile= s:NetrwHome()."/.netrwhist"
                            "  call Decho("savefile<".savefile.">",'~'.expand("<slnum>"))
    1              0.000067   1split
                            
                              " setting up a new buffer which will become .netrwhist
    1   0.061758   0.000014   call s:NetrwEnew()
                            "  call Decho("case g:netrw_use_noswf=".g:netrw_use_noswf.(exists("+acd")? " +acd" : " -acd"),'~'.expand("<slnum>"))
    1              0.000001   if g:netrw_use_noswf
    1              0.000029    setl cino= com= cpo-=a cpo-=A fo=nroql2 tw=0 report=10000 noswf
                              else
                               setl cino= com= cpo-=a cpo-=A fo=nroql2 tw=0 report=10000
    1              0.000000   endif
    1              0.000019   setl nocin noai noci magic nospell nohid wig= noaw
    1              0.000009   setl ma noro write
    1              0.000008   if exists("+acd") | setl noacd | endif
    1              0.000007   sil! NetrwKeepj keepalt %d _
                            
                              " rename enew'd file: .netrwhist -- no attempt to merge
                              " record dirhistmax and current dirhistcnt
                              " save history
                            "  call Decho("saving history: dirhistmax=".g:netrw_dirhistmax." dirhistcnt=".g:netrw_dirhistcnt." lastline=".line("$"),'~'.expand("<slnum>"))
    1              0.000080   sil! keepalt file .netrwhist
    1              0.000010   call setline(1,"let g:netrw_dirhistmax  =".g:netrw_dirhistmax)
    1              0.000008   call setline(2,"let g:netrw_dirhistcnt =".g:netrw_dirhistcnt)
    1              0.000002   if g:netrw_dirhistmax > 0
    1              0.000003    let lastline = line("$")
    1              0.000002    let cnt      = g:netrw_dirhistcnt
    1              0.000001    let first    = 1
   11              0.000016    while ( first || cnt != g:netrw_dirhistcnt )
   10              0.000013     let lastline= lastline + 1
   10              0.000028     if exists("g:netrw_dirhist_{cnt}")
   10              0.000050      call setline(lastline,'let g:netrw_dirhist_'.cnt."='".g:netrw_dirhist_{cnt}."'")
                            "     call Decho("..".lastline.'let g:netrw_dirhist_'.cnt."='".g:netrw_dirhist_{cnt}."'",'~'.expand("<slnum>"))
   10              0.000003     endif
   10              0.000010     let first   = 0
   10              0.000018     let cnt     = ( cnt - 1 ) % g:netrw_dirhistmax
   10              0.000009     if cnt < 0
    1              0.000002      let cnt= cnt + g:netrw_dirhistmax
   10              0.000002     endif
   11              0.000010    endwhile
    1              0.017508    exe "sil! w! ".savefile
                            "   call Decho("exe sil! w! ".savefile,'~'.expand("<slnum>"))
    1              0.000003   endif
                            
                              " save bookmarks
    1              0.000021   sil NetrwKeepj %d _
    1              0.000011   if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != []
                            "   call Decho("saving bookmarks",'~'.expand("<slnum>"))
                               " merge and write .netrwbook
                               let savefile= s:NetrwHome()."/.netrwbook"
                            
                               if filereadable(s:NetrwFile(savefile))
                                let booklist= deepcopy(g:netrw_bookmarklist)
                                exe "sil NetrwKeepj keepalt so ".savefile
                                for bdm in booklist
                                 if index(g:netrw_bookmarklist,bdm) == -1
                                  call add(g:netrw_bookmarklist,bdm)
                                 endif
                                endfor
                                call sort(g:netrw_bookmarklist)
                               endif
                            
                               " construct and save .netrwbook
                               call setline(1,"let g:netrw_bookmarklist= ".string(g:netrw_bookmarklist))
                               exe "sil! w! ".savefile
                            "   call Decho("exe sil! w! ".savefile,'~'.expand("<slnum>"))
    1              0.000000   endif
                            
                              " cleanup -- remove buffer used to construct history
    1              0.000005   let bgone= bufnr("%")
    1              0.000123   q!
    1              0.000108   exe "keepalt ".bgone."bwipe!"
                            
                            "  call Dret("s:NetrwBookHistSave")

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/parts.vim:101
Called 30 times
Total time:   0.000204
 Self time:   0.000204

count  total (s)   self (s)
   30              0.000186   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  go#lsp#message#DidChange()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp/message.vim:173
Called 1 time
Total time:   0.000089
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000088   0.000016   return { 'notification': 1, 'method': 'textDocument/didChange', 'params': {     'textDocument': {         'uri': go#path#ToURI(a:file),         'version': a:version,     },     'contentChanges': [       {         'text': a:content,       }     ] } }

FUNCTION  airline#extensions#tabline#add_label()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline.vim:206
Called 1 time
Total time:   0.000023
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000003   if get(g:, 'airline#extensions#tabline#show_tab_type', 1)
    1   0.000019   0.000008     call a:dict.add_section_spaced('airline_tablabel', get(g:, 'airline#extensions#tabline#'.a:type.'_label', a:type))
    1              0.000001   endif

FUNCTION  go#config#HighlightFunctionCalls()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:449
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return get(g:, 'go_highlight_function_calls', 0)

FUNCTION  <SNR>93_handleCodeAction()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:1657
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000003   if type(a:msg) is type('')
                                call self.handleError(a:msg)
                                return
    1              0.000001   endif
                            
    1              0.000002   if a:msg is v:null
    1              0.000000     return
                              endif
                            
                              for l:item in a:msg
                                if get(l:item, 'kind', '') is a:kind
                                  if !has_key(l:item, 'edit')
                                    continue
                                  endif
                            
                                  if has_key(l:item, 'disabled') && get(l:item.disabled, 'reason', '') isnot ''
                                    call go#util#EchoWarning(printf('code action is disabled: %s', l:item.disabled.reason))
                                    continue
                                  endif
                            
                                  if has_key(l:item, 'command')
                                    if has_key(l:item.command, 'command') && (l:item.command.command is a:cmd || l:item.command.command is printf('gopls.%s', a:cmd))
                                      call s:executeCommand(l:item.command.command, l:item.command.arguments)
                                      continue
                                    endif
                                  endif
                            
                                  if !has_key(l:item.edit, 'documentChanges')
                                    continue
                                  endif
                                  call s:applyDocumentChanges(l:item.edit.documentChanges)
                                endif
                              endfor

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/default.vim:79
Called 3 times
Total time:   0.001500
 Self time:   0.000170

count  total (s)   self (s)
    3              0.000006   let winnr = a:context.winnr
    3              0.000003   let active = a:context.active
                            
    3   0.000031   0.000021   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    1   0.000251   0.000008     call s:build_sections(a:builder, a:context, s:layout[0])
    2              0.000002   else
    2   0.000086   0.000014     let text = s:get_section(winnr, 'c')
    2              0.000002     if empty(text)
                                  let text = ' %f%m '
    2              0.000002     endif
    2   0.000021   0.000012     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    3              0.000000   endif
                            
    3   0.000140   0.000028   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    3   0.000024   0.000016   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    3   0.000898   0.000022     call s:build_sections(a:builder, a:context, s:layout[1])
    3              0.000002   endif
                            
    3              0.000003   return 1

FUNCTION  <SNR>72_NetrwBufRemover()
    Defined: /usr/local/Cellar/macvim/9.0.0065/MacVim.app/Contents/Resources/vim/runtime/autoload/netrw.vim:11968
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwBufRemover(".a:bufid.")")
                            "  call Decho("buf#".a:bufid."           ".((a:bufid > 1)? ">" : "≯")." must be >1 for removal","~".expand("<slnum>"))
                            "  call Decho("buf#".a:bufid." is        ".(buflisted(a:bufid)? "listed" : "unlisted"),"~".expand("<slnum>"))
                            "  call Decho("buf#".a:bufid." has name <".bufname(a:bufid).">","~".expand("<slnum>"))
                            "  call Decho("buf#".a:bufid." has winid#".bufwinid(a:bufid),"~".expand("<slnum>"))
                            
    1              0.000008   if a:bufid > 1 && !buflisted(a:bufid) && bufname(a:bufid) == "" && bufwinid(a:bufid) == -1
                            "   call Decho("(s:NetrwBufRemover) removing buffer#".a:bufid,"~".expand("<slnum>"))
    1              0.000007    exe "bd! ".a:bufid
    1              0.000001   endif
                            
                            "  call Dret("s:NetrwBufRemover")

FUNCTION  <SNR>72_NetrwOptionsSave()
    Defined: /usr/local/Cellar/macvim/9.0.0065/MacVim.app/Contents/Resources/vim/runtime/autoload/netrw.vim:1643
Called 1 time
Total time:   0.001119
 Self time:   0.001119

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwOptionsSave(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%")).">"." winnr($)=".winnr("$")." mod=".&mod." ma=".&ma)
                            "  call Decho(a:vt."netrw_optionsave".(exists("{a:vt}netrw_optionsave")? ("=".{a:vt}netrw_optionsave) : " doesn't exist"),'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt." hid=".&hid,'~'.expand("<slnum>"))
                            "  call Decho("(s:NetrwOptionsSave) lines=".&lines)
                            
    1              0.000005   if !exists("{a:vt}netrw_optionsave")
    1              0.000004    let {a:vt}netrw_optionsave= 1
                              else
                            "   call Dret("s:NetrwOptionsSave : options already saved")
                               return
    1              0.000001   endif
                            "  call Decho("prior to save: fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." diff=".&l:diff,'~'.expand("<slnum>"))
                            
                              " Save current settings and current directory
                            "  call Decho("saving current settings and current directory",'~'.expand("<slnum>"))
    1              0.000008   let s:yykeep          = @@
    1              0.000010   if exists("&l:acd")|let {a:vt}netrw_acdkeep  = &l:acd|endif
    1              0.000004   let {a:vt}netrw_aikeep    = &l:ai
    1              0.000004   let {a:vt}netrw_awkeep    = &l:aw
    1              0.000004   let {a:vt}netrw_bhkeep    = &l:bh
    1              0.000004   let {a:vt}netrw_blkeep    = &l:bl
    1              0.000004   let {a:vt}netrw_btkeep    = &l:bt
    1              0.000002   let {a:vt}netrw_bombkeep  = &l:bomb
    1              0.000003   let {a:vt}netrw_cedit     = &cedit
    1              0.000004   let {a:vt}netrw_cikeep    = &l:ci
    1              0.000003   let {a:vt}netrw_cinkeep   = &l:cin
    1              0.000004   let {a:vt}netrw_cinokeep  = &l:cino
    1              0.000004   let {a:vt}netrw_comkeep   = &l:com
    1              0.000004   let {a:vt}netrw_cpokeep   = &l:cpo
    1              0.000004   let {a:vt}netrw_cuckeep   = &l:cuc
    1              0.000004   let {a:vt}netrw_culkeep   = &l:cul
                            "  call Decho("(s:NetrwOptionsSave) COMBAK: cuc=".&l:cuc." cul=".&l:cul)
    1              0.000002   let {a:vt}netrw_diffkeep  = &l:diff
    1              0.000003   let {a:vt}netrw_fenkeep   = &l:fen
    1              0.000003   if !exists("g:netrw_ffkeep") || g:netrw_ffkeep
    1              0.000004    let {a:vt}netrw_ffkeep    = &l:ff
    1              0.000000   endif
    1              0.000003   let {a:vt}netrw_fokeep    = &l:fo           " formatoptions
    1              0.000003   let {a:vt}netrw_gdkeep    = &l:gd           " gdefault
    1              0.000004   let {a:vt}netrw_gokeep    = &l:go           " guioptions
    1              0.000002   let {a:vt}netrw_hidkeep   = &l:hidden
    1              0.000003   let {a:vt}netrw_imkeep    = &l:im
    1              0.000004   let {a:vt}netrw_iskkeep   = &l:isk
    1              0.000002   let {a:vt}netrw_lines     = &lines
    1              0.000003   let {a:vt}netrw_lskeep    = &l:ls
    1              0.000003   let {a:vt}netrw_makeep    = &l:ma
    1              0.000002   let {a:vt}netrw_magickeep = &l:magic
    1              0.000004   let {a:vt}netrw_modkeep   = &l:mod
    1              0.000003   let {a:vt}netrw_nukeep    = &l:nu
    1              0.000003   let {a:vt}netrw_rnukeep   = &l:rnu
    1              0.000002   let {a:vt}netrw_repkeep   = &l:report
    1              0.000003   let {a:vt}netrw_rokeep    = &l:ro
    1              0.000003   let {a:vt}netrw_selkeep   = &l:sel
    1              0.000002   let {a:vt}netrw_spellkeep = &l:spell
    1              0.000002   if !g:netrw_use_noswf
                               let {a:vt}netrw_swfkeep  = &l:swf
    1              0.000000   endif
    1              0.000003   let {a:vt}netrw_tskeep    = &l:ts
    1              0.000003   let {a:vt}netrw_twkeep    = &l:tw           " textwidth
    1              0.000003   let {a:vt}netrw_wigkeep   = &l:wig          " wildignore
    1              0.000002   let {a:vt}netrw_wrapkeep  = &l:wrap
    1              0.000002   let {a:vt}netrw_writekeep = &l:write
                            
                              " save a few selected netrw-related variables
                            "  call Decho("saving a few selected netrw-related variables",'~'.expand("<slnum>"))
    1              0.000002   if g:netrw_keepdir
    1              0.000035    let {a:vt}netrw_dirkeep  = getcwd()
                            "   call Decho("saving to ".a:vt."netrw_dirkeep<".{a:vt}netrw_dirkeep.">",'~'.expand("<slnum>"))
    1              0.000001   endif
    1              0.000003   if has("clipboard") && g:netrw_clipboard
    1              0.000859    sil! let {a:vt}netrw_starkeep = @*
    1              0.000036    sil! let {a:vt}netrw_pluskeep = @+
    1              0.000002   endif
    1              0.000004   sil! let {a:vt}netrw_slashkeep= @/
                            
                            "  call Decho("(s:NetrwOptionsSave) lines=".&lines)
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwOptionsSave : tab#".tabpagenr()." win#".winnr())

FUNCTION  <SNR>61_get_array()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim:44
Called 884 times
Total time:   0.007443
 Self time:   0.007443

count  total (s)   self (s)
  884              0.003050   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  884              0.003932   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  go#list#Type()
    Defined: ~/.vim/bundle/vim-go/autoload/go/list.vim:174
Called 2 times
Total time:   0.000115
 Self time:   0.000074

count  total (s)   self (s)
    2   0.000061   0.000029   let l:listtype = s:listtype(get(s:default_list_type_commands, a:for))
    2              0.000003   if l:listtype == "0"
                                call go#util#EchoError(printf( "unknown list type command value found ('%s'). Please open a bug report in the vim-go repo.", a:for))
                                let l:listtype = "quickfix"
    2              0.000001   endif
                            
    2   0.000037   0.000028   return get(go#config#ListTypeCommands(), a:for, l:listtype)

FUNCTION  go#config#ListType()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:132
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000007   return get(g:, 'go_list_type', '')

FUNCTION  <SNR>48_invoke_funcrefs()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline.vim:127
Called 3 times
Total time:   0.020216
 Self time:   0.000123

count  total (s)   self (s)
    3   0.000079   0.000018   let builder = airline#builder#new(a:context)
    3   0.002039   0.000028   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    3              0.000003   if err == 1
    3   0.018041   0.000020     let a:context.line = builder.build()
    3              0.000018     let s:contexts[a:context.winnr] = a:context
    3              0.000029     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
    3              0.000001   endif

FUNCTION  <SNR>93_applyTextEdits()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:1745
Called 1 time
Total time:   0.000213
 Self time:   0.000129

count  total (s)   self (s)
    1              0.000002   if a:msg is v:null
                                return
    1              0.000001   endif
                            
                              " TODO(bc): start using the functions to modify a buffer (e.g. appendbufline,
                              " deletebufline, etc) instead of operating on the current buffer when vim-go
                              " drops support from Vim 8.0.
                            
                              " process the TextEdit list in reverse order, because the positions are
                              " based on the current line numbers; processing in forward order would
                              " require keeping track of how the proper position of each TextEdit would be
                              " affected by all the TextEdits that came before.
    1              0.000007   call reverse(sort(a:msg, function('s:textEditLess')))
    1              0.000002   for l:msg in a:msg
                                let l:startline = l:msg.range.start.line+1
                                let l:endline = l:msg.range.end.line+1
                                let l:text = l:msg.newText
                            
                                " handle the deletion of whole lines
                                if len(l:text) == 0 && l:msg.range.start.character == 0 && l:msg.range.end.character == 0 && l:startline < l:endline
                                  call s:deleteline(l:startline, l:endline-1)
                                  continue
                                endif
                            
                                " Assume that l:startcontent will be an empty string. When the replacement
                                " is not at the beginning of the line, then l:startcontent must be what
                                " comes before the start position on the start line.
                                let l:startcontent = ''
                                if l:msg.range.start.character > 0
                                  let l:startcontent = getline(l:startline)
                                  let l:preSliceEnd = go#lsp#lsp#PositionOf(l:startcontent, l:msg.range.start.character-1) - 1
                                  let l:startcontent = l:startcontent[:l:preSliceEnd]
                                endif
                            
                                let l:endcontent = getline(l:endline)
                                let l:postSliceStart = 0
                                if l:msg.range.end.character > 0
                                  let l:postSliceStart = go#lsp#lsp#PositionOf(l:endcontent, l:msg.range.end.character-1)
                                  let l:endcontent = l:endcontent[(l:postSliceStart):]
                                endif
                            
                                " There isn't an easy way to replace the text in a byte or character
                                " range, so append to l:text any text on l:endline starting from
                                " l:postSliceStart and prepend to l:text any text on l:startline prior to
                                " l:preSliceEnd, and finally replace the lines with a delete followed by
                                " and append.
                                let l:text = printf('%s%s%s', l:startcontent, l:text, l:endcontent)
                            
                                " TODO(bc): deal with the undo file
                                " TODO(bc): deal with folds
                            
                                " TODO(bc): can we use appendbufline instead of deleting and appending?
                                call s:deleteline(l:startline, l:endline)
                                for l:line in split(l:text, "\n", 1)
                                  call append(l:startline-1, l:line)
                                  let l:startline += 1
                                endfor
    1              0.000002   endfor
                            
    1   0.000146   0.000062   call go#lsp#DidChange(expand('%:p'))
    1              0.000001   return

FUNCTION  <SNR>93_debugasync()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:1290
Called 4 times
Total time:   0.000110
 Self time:   0.000054

count  total (s)   self (s)
    4   0.000086   0.000030   if !go#util#HasDebug('lsp')
    4              0.000015     let s:log = []
    4              0.000004     return
                              endif
                            
                              let l:winid = win_getid()
                            
                              let l:name = '__GOLSP_LOG__'
                              let l:log_winid = bufwinid(l:name)
                              if l:log_winid == -1
                                silent keepalt botright 10new
                                silent file `='__GOLSP_LOG__'`
                                setlocal buftype=nofile bufhidden=wipe nomodified nobuflisted noswapfile nowrap nonumber nocursorline
                                setlocal filetype=golsplog
                              else
                                call win_gotoid(l:log_winid)
                              endif
                            
                              try
                                setlocal modifiable
                                for [l:event, l:data] in s:log
                                  call remove(s:log, 0)
                                  if getline(1) == ''
                                    call setline('$', printf('===== %s =====', l:event))
                                  else
                                    call append('$', printf('===== %s =====', l:event))
                                  endif
                                  call append('$', split(l:data, "\r\n"))
                                endfor
                                normal! G
                                setlocal nomodifiable
                              finally
                                call win_gotoid(l:winid)
                              endtry

FUNCTION  go#config#FmtAutosave()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:313
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000007 	return get(g:, "go_fmt_autosave", 1)

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim:26
Called 130 times
Total time:   0.000678
 Self time:   0.000678

count  total (s)   self (s)
  130              0.000311   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
  130              0.000073   endif
  130              0.000131   return a:text

FUNCTION  go#auto#update_autocmd()
    Defined: ~/.vim/bundle/vim-go/autoload/go/auto.vim:86
Called 4 times
Total time:   0.000104
 Self time:   0.000080

count  total (s)   self (s)
    4              0.000012   let has_timer = get(b:, 'has_timer')
    4   0.000063   0.000039   let should_enable = go#config#AutoTypeInfo() || go#config#AutoSameids()
    4              0.000010   if (!has_timer && !should_enable) || (has_timer && should_enable)
    4              0.000012     return
                              endif
                            
                              if has_timer
                                augroup vim-go-buffer-auto
                                  autocmd! * <buffer>
                                augroup END
                                let b:has_timer = 0
                                call s:timer_stop()
                                return
                              endif
                            
                              augroup vim-go-buffer-auto
                                autocmd! * <buffer>
                                autocmd CursorMoved <buffer> call s:timer_restart()
                                autocmd BufLeave <buffer> call s:timer_stop()
                              augroup END
                              let b:has_timer = 1
                              call s:timer_start()

FUNCTION  airline#extensions#tabline#get()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline.vim:116
Called 8 times
Total time:   0.012330
 Self time:   0.000317

count  total (s)   self (s)
    8              0.000035   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
    8              0.000024   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
    8              0.000019   let curtabcnt = tabpagenr('$')
    8              0.000015   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
    8              0.000005   endif
                            
    8              0.000028   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
    8              0.000004   endif
    8              0.000008   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
    8              0.000019   elseif show_buffers && curtabcnt == 1 || !show_tabs
    8   0.012083   0.000070     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  <SNR>52_ws_refresh()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/whitespace.vim:162
Called 5 times
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
    5              0.000047   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    4              0.000006     return
    1              0.000001   endif
    1              0.000003   unlet! b:airline_whitespace_check
    1              0.000003   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
    1              0.000001   endif
    1              0.000003   let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>67_OnFileReadyToParse()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:746
Called 1 time
Total time:   0.000762
 Self time:   0.000355

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
    1              0.000004   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
    1              0.000003   if force_parsing || py3eval( "ycm_state.NeedsReparse()" )
                                " We switched buffers or somethuing, so claer.
                                " FIXME: sig hekp should be buffer local?
    1   0.000403   0.000007     call s:ClearSignatureHelp()
    1              0.000293     py3 ycm_state.OnFileReadyToParse()
                            
    1   0.000020   0.000013     call s:StopPoller( s:pollers.file_parse_response )
    1              0.000009     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                            
    1   0.000010   0.000006     call s:StopPoller( s:pollers.semantic_highlighting )
    1              0.000005     if !s:is_neovim && get( b:, 'ycm_enable_semantic_highlighting',   get( g:, 'ycm_enable_semantic_highlighting', 0 ) )
                            
                                  py3 ycm_state.CurrentBuffer().SendSemanticTokensRequest()
                                  let s:pollers.semantic_highlighting.id = timer_start( s:pollers.semantic_highlighting.wait_milliseconds, function( 's:PollSemanticHighlighting' ) )
                            
    1              0.000001     endif
    1              0.000000   endif

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim:37
Called 29 times
Total time:   0.000329
 Self time:   0.000329

count  total (s)   self (s)
   29              0.000050   let x = a:i - 1
   34              0.000042   while x >= 0
   28              0.000068     let group = a:sections[x][0]
   28              0.000052     if group != '' && group != '|'
   23              0.000023       return group
    5              0.000004     endif
    5              0.000005     let x = x - 1
   11              0.000009   endwhile
    6              0.000005   return ''

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/whitespace.vim:50
Called 20 times
Total time:   0.002975
 Self time:   0.002327

count  total (s)   self (s)
   20              0.000078   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   20              0.000120   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
   20              0.000014   endif
   20              0.000132   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
   20              0.000061   if !exists('b:airline_whitespace_check')
    1              0.000002     let b:airline_whitespace_check = ''
    1              0.000005     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    1              0.000001     let trailing = 0
    1              0.000002     let check = 'trailing'
    1              0.000007     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1              0.000001       try
    1              0.000003         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    1              0.000109         let trailing = search(regexp, 'nw')
                                  catch
                                    echomsg 'airline#whitespace: error occurred evaluating '. regexp
                                    echomsg v:exception
                                    return ''
    1              0.000001       endtry
    1              0.000001     endif
                            
    1              0.000002     let mixed = 0
    1              0.000001     let check = 'indent'
    1              0.000007     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.000234   0.000007       let mixed = s:check_mixed_indent()
    1              0.000001     endif
                            
    1              0.000002     let mixed_file = ''
    1              0.000001     let check = 'mixed-indent-file'
    1              0.000007     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.000076   0.000009       let mixed_file = s:check_mixed_indent_file()
    1              0.000001     endif
                            
    1              0.000001     let long = 0
    1              0.000003     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
    1              0.000001     endif
                            
    1              0.000003     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                  endif
    1              0.000000     endif
   20              0.000007   endif
   20   0.000486   0.000132   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>93_newHandlerState()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:527
Called 3 times
Total time:   0.000173
 Self time:   0.000173

count  total (s)   self (s)
    3              0.000118   let l:state = { 'winid': win_getid(winnr()), 'statustype': a:statustype, 'jobdir': getcwd(), 'handleResult': funcref('s:noop'), }
                            
                              " explicitly bind requestComplete to state so that within it, self will
                              " always refer to state. See :help Partial for more information.
    3              0.000021   let l:state.requestComplete = funcref('s:requestComplete', [], l:state)
                            
                              " explicitly bind start to state so that within it, self will
                              " always refer to state. See :help Partial for more information.
    3              0.000013   let l:state.start = funcref('s:start', [], l:state)
                            
    3              0.000003   return l:state

FUNCTION  <SNR>96_encode()
    Defined: ~/.vim/bundle/vim-go/autoload/go/uri.vim:17
Called 3 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    3              0.000040     return substitute(   a:value,   a:unreserved,   '\=s:encodechar(submatch(0))',   'g')

FUNCTION  <SNR>52_check_mixed_indent_file()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/whitespace.vim:32
Called 1 time
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    1              0.000006   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    1              0.000004   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
    1              0.000002     let head_spc = '\v(^ +\*@!)'
                              else
                                let head_spc = '\v(^ +)'
    1              0.000001   endif
    1              0.000008   let indent_tabs = search('\v(^\t+)', 'nw')
    1              0.000039   let indent_spc  = search(head_spc, 'nw')
    1              0.000002   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
    1              0.000001   else
    1              0.000001     return ''
                              endif

FUNCTION  23()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:133
Called 2 times
Total time:   0.000935
 Self time:   0.000129

count  total (s)   self (s)
    2              0.000024       let self.buf .= a:data
                            
    2   0.000337   0.000023       let [self.buf, l:messages] = self.readMessage(self.buf)
                            
    4              0.000005       for l:message in l:messages
    2              0.000006         if has_key(l:message, 'method')
                                      if has_key(l:message, 'id')
                                        call self.handleRequest(l:message)
                                      else
                                        call self.handleNotification(l:message)
                                      endif
    2              0.000006         elseif has_key(l:message, 'result') || has_key(l:message, 'error')
    2   0.000502   0.000010           call self.handleResponse(l:message)
    2              0.000001         endif
    4              0.000008       endfor

FUNCTION  <SNR>95_codeAction()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp/message.vim:101
Called 1 time
Total time:   0.000107
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000106   0.000027   return { 'notification': 0, 'method': 'textDocument/codeAction', 'params': {   'textDocument': {       'uri': go#path#ToURI(a:file)   },   'range': {     'start': s:position(0, 0),     'end': s:position(line('$'), 0),   },   'context': {     'only': [a:name],   }, } }

FUNCTION  <SNR>75_hi()
    Defined: ~/.vim/bundle/vim-go/syntax/go.vim:395
Called 1 time
Total time:   0.000092
 Self time:   0.000087

count  total (s)   self (s)
    1              0.000009   hi def link goSameId Search
    1              0.000004   hi def link goDiagnosticError SpellBad
    1              0.000003   hi def link goDiagnosticWarning SpellRare
                            
                              " TODO(bc): is it appropriate to define text properties in a syntax file?
                              " The highlight groups need to be defined before the text properties types
                              " are added, and when users have syntax enabled in their vimrc after
                              " filetype plugin on, the highlight groups won't be defined when
                              " ftplugin/go.vim is executed when the first go file is opened.
                              " See https://github.com/fatih/vim-go/issues/2658.
    1              0.000007   if has('textprop')
    1              0.000007     if empty(prop_type_get('goSameId'))
                                  call prop_type_add('goSameId', {'highlight': 'goSameId'})
    1              0.000001     endif
    1              0.000004     if empty(prop_type_get('goDiagnosticError'))
                                  call prop_type_add('goDiagnosticError', {'highlight': 'goDiagnosticError'})
    1              0.000001     endif
    1              0.000003     if empty(prop_type_get('goDiagnosticWarning'))
                                  call prop_type_add('goDiagnosticWarning', {'highlight': 'goDiagnosticWarning'})
    1              0.000000     endif
    1              0.000001   endif
                            
    1              0.000005   hi def link goDeclsFzfKeyword        Keyword
    1              0.000003   hi def link goDeclsFzfFunction       Function
    1              0.000003   hi def link goDeclsFzfSpecialComment SpecialComment
    1              0.000004   hi def link goDeclsFzfComment        Comment
                            
                              " :GoCoverage commands
    1              0.000002   hi def      goCoverageCovered    ctermfg=green guifg=#A6E22E
    1              0.000002   hi def      goCoverageUncover    ctermfg=red guifg=#F92672
                            
                              " :GoDebug commands
    1   0.000012   0.000007   if go#config#HighlightDebug()
    1              0.000002     hi def GoDebugBreakpoint term=standout ctermbg=117 ctermfg=0 guibg=#BAD4F5  guifg=Black
    1              0.000002     hi def GoDebugCurrent term=reverse  ctermbg=12  ctermfg=7 guibg=DarkBlue guifg=White
    1              0.000001   endif

FUNCTION  <SNR>54_wordcount_update()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/wordcount.vim:10
Called 2 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    2              0.000006   if empty(bufname(''))
                                return
    2              0.000002   endif
    2              0.000032   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                let l:mode = mode()
                                if l:mode ==# 'v' || l:mode ==# 'V' || l:mode ==# 's' || l:mode ==# 'S'
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_change_tick = b:changedtick
                                else
                                  if get(b:, 'airline_wordcount_cache', '') is# '' || b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') || get(b:, 'airline_change_tick', 0) != b:changedtick ||  get(b:, 'airline_winwidth', 0) != winwidth(0)
                                    " cache data
                                    let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    let b:airline_wordcount_cache = b:airline_wordcount
                                    let b:airline_change_tick = b:changedtick
                                    let b:airline_winwidth = winwidth(0)
                                  endif
                                endif
    2              0.000002   endif

FUNCTION  <SNR>22_on_window_changed()
    Defined: ~/.vim/bundle/vim-airline/plugin/airline.vim:39
Called 43 times
Total time:   0.021782
 Self time:   0.001419

count  total (s)   self (s)
   43              0.000123   let s:active_winnr = winnr()
                            
   43              0.000102   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
   43              0.000024   endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
   43              0.000406   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
   43              0.000527   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
   42              0.000030     return
    1              0.000001   endif
    1              0.000002   let g:airline_last_window_changed = l:key
    1   0.000010   0.000007   call s:init()
    1   0.020367   0.000007   call airline#update_statusline()

FUNCTION  airline#extensions#tabline#group_of_bufnr()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline.vim:186
Called 6 times
Total time:   0.000134
 Self time:   0.000134

count  total (s)   self (s)
    6              0.000015   let cur = bufnr('%')
    6              0.000007   if cur == a:bufnr
    3              0.000013     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                  let group = 'airline_tabmod'
    3              0.000001     else
    3              0.000005       let group = 'airline_tabsel'
    3              0.000001     endif
    3              0.000003   else
    3              0.000010     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                  let group = 'airline_tabmod_unsel'
    3              0.000008     elseif index(a:tab_bufs, a:bufnr) > -1
                                  let group = 'airline_tab'
    3              0.000001     else
    3              0.000005       let group = 'airline_tabhid'
    3              0.000001     endif
    6              0.000004   endif
    6              0.000006   return group

FUNCTION  go#config#HighlightGenerateTags()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:473
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return get(g:, 'go_highlight_generate_tags', 0)

FUNCTION  <SNR>72_NetrwOptionsRestore()
    Defined: /usr/local/Cellar/macvim/9.0.0065/MacVim.app/Contents/Resources/vim/runtime/autoload/netrw.vim:1788
Called 1 time
Total time:   0.060303
 Self time:   0.000020

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwOptionsRestore(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
                            "  call Decho("(s:NetrwOptionsRestore) lines=".&lines)
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
    1              0.000004   if !exists("{a:vt}netrw_optionsave")
                            "   call Decho("case ".a:vt."netrw_optionsave : doesn't exist",'~'.expand("<slnum>"))
                            "   call Decho("..doing filetype detect anyway")
    1   0.060288   0.000005    filetype detect
                            "   call Decho("..settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                            "   call Decho("..ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "   call Dret("s:NetrwOptionsRestore : ".a:vt."netrw_optionsave doesn't exist")
    1              0.000001    return
                              endif
                              unlet {a:vt}netrw_optionsave
                            
                              if exists("+acd")
                               if exists("{a:vt}netrw_acdkeep")
                            "    call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
                                let curdir = getcwd()
                                let &l:acd = {a:vt}netrw_acdkeep
                                unlet {a:vt}netrw_acdkeep
                                if &l:acd
                                 call s:NetrwLcd(curdir)
                                endif
                               endif
                              endif
                            "  call Decho("(s:NetrwOptionsRestore) #1 lines=".&lines)
                              call s:NetrwRestoreSetting(a:vt."netrw_aikeep","&l:ai")
                              call s:NetrwRestoreSetting(a:vt."netrw_awkeep","&l:aw")
                              call s:NetrwRestoreSetting(a:vt."netrw_blkeep","&l:bl")
                              call s:NetrwRestoreSetting(a:vt."netrw_btkeep","&l:bt")
                              call s:NetrwRestoreSetting(a:vt."netrw_bombkeep","&l:bomb")
                            "  call Decho("(s:NetrwOptionsRestore) #2 lines=".&lines)
                              call s:NetrwRestoreSetting(a:vt."netrw_cedit","&cedit")
                              call s:NetrwRestoreSetting(a:vt."netrw_cikeep","&l:ci")
                              call s:NetrwRestoreSetting(a:vt."netrw_cinkeep","&l:cin")
                              call s:NetrwRestoreSetting(a:vt."netrw_cinokeep","&l:cino")
                              call s:NetrwRestoreSetting(a:vt."netrw_comkeep","&l:com")
                            "  call Decho("(s:NetrwOptionsRestore) #3 lines=".&lines)
                              call s:NetrwRestoreSetting(a:vt."netrw_cpokeep","&l:cpo")
                              call s:NetrwRestoreSetting(a:vt."netrw_diffkeep","&l:diff")
                              call s:NetrwRestoreSetting(a:vt."netrw_fenkeep","&l:fen")
                              if exists("g:netrw_ffkeep") && g:netrw_ffkeep
                               call s:NetrwRestoreSetting(a:vt."netrw_ffkeep")","&l:ff")
                              endif
                            "  call Decho("(s:NetrwOptionsRestore) #4 lines=".&lines)
                              call s:NetrwRestoreSetting(a:vt."netrw_fokeep"   ,"&l:fo")
                              call s:NetrwRestoreSetting(a:vt."netrw_gdkeep"   ,"&l:gd")
                              call s:NetrwRestoreSetting(a:vt."netrw_gokeep"   ,"&l:go")
                              call s:NetrwRestoreSetting(a:vt."netrw_hidkeep"  ,"&l:hidden")
                            "  call Decho("(s:NetrwOptionsRestore) #5 lines=".&lines)
                              call s:NetrwRestoreSetting(a:vt."netrw_imkeep"   ,"&l:im")
                              call s:NetrwRestoreSetting(a:vt."netrw_iskkeep"  ,"&l:isk")
                            "  call Decho("(s:NetrwOptionsRestore) #6 lines=".&lines)
                              call s:NetrwRestoreSetting(a:vt."netrw_lines"    ,"&lines")
                            "  call Decho("(s:NetrwOptionsRestore) #7 lines=".&lines)
                              call s:NetrwRestoreSetting(a:vt."netrw_lskeep"   ,"&l:ls")
                              call s:NetrwRestoreSetting(a:vt."netrw_makeep"   ,"&l:ma")
                              call s:NetrwRestoreSetting(a:vt."netrw_magickeep","&l:magic")
                              call s:NetrwRestoreSetting(a:vt."netrw_modkeep"  ,"&l:mod")
                              call s:NetrwRestoreSetting(a:vt."netrw_nukeep"   ,"&l:nu")
                            "  call Decho("(s:NetrwOptionsRestore) #8 lines=".&lines)
                              call s:NetrwRestoreSetting(a:vt."netrw_rnukeep"  ,"&l:rnu")
                              call s:NetrwRestoreSetting(a:vt."netrw_repkeep"  ,"&l:report")
                              call s:NetrwRestoreSetting(a:vt."netrw_rokeep"   ,"&l:ro")
                              call s:NetrwRestoreSetting(a:vt."netrw_selkeep"  ,"&l:sel")
                            "  call Decho("(s:NetrwOptionsRestore) #9 lines=".&lines)
                              call s:NetrwRestoreSetting(a:vt."netrw_spellkeep","&l:spell")
                              call s:NetrwRestoreSetting(a:vt."netrw_twkeep"   ,"&l:tw")
                              call s:NetrwRestoreSetting(a:vt."netrw_wigkeep"  ,"&l:wig")
                              call s:NetrwRestoreSetting(a:vt."netrw_wrapkeep" ,"&l:wrap")
                              call s:NetrwRestoreSetting(a:vt."netrw_writekeep","&l:write")
                            "  call Decho("(s:NetrwOptionsRestore) #10 lines=".&lines)
                              call s:NetrwRestoreSetting("s:yykeep","@@")
                              " former problem: start with liststyle=0; press <i> : result, following line resets l:ts.
                              " Fixed; in s:PerformListing, when w:netrw_liststyle is s:LONGLIST, will use a printf to pad filename with spaces
                              "        rather than by appending a tab which previously was using "&ts" to set the desired spacing.  (Sep 28, 2018)
                              call s:NetrwRestoreSetting(a:vt."netrw_tskeep","&l:ts")
                            
                              if exists("{a:vt}netrw_swfkeep")
                               if &directory == ""
                                " user hasn't specified a swapfile directory;
                                " netrw will temporarily set the swapfile directory
                                " to the current directory as returned by getcwd().
                                let &l:directory= getcwd()
                                sil! let &l:swf = {a:vt}netrw_swfkeep
                                setl directory=
                                unlet {a:vt}netrw_swfkeep
                               elseif &l:swf != {a:vt}netrw_swfkeep
                                if !g:netrw_use_noswf
                                 " following line causes a Press ENTER in windows -- can't seem to work around it!!!
                                 sil! let &l:swf= {a:vt}netrw_swfkeep
                                endif
                                unlet {a:vt}netrw_swfkeep
                               endif
                              endif
                              if exists("{a:vt}netrw_dirkeep") && isdirectory(s:NetrwFile({a:vt}netrw_dirkeep)) && g:netrw_keepdir
                               let dirkeep = substitute({a:vt}netrw_dirkeep,'\\','/','g')
                               if exists("{a:vt}netrw_dirkeep")
                                call s:NetrwLcd(dirkeep)
                                unlet {a:vt}netrw_dirkeep
                               endif
                              endif
                              if has("clipboard") && g:netrw_clipboard
                            "   call Decho("has clipboard",'~'.expand("<slnum>"))
                               call s:NetrwRestoreSetting(a:vt."netrw_starkeep","@*")
                               call s:NetrwRestoreSetting(a:vt."netrw_pluskeep","@+")
                              endif
                              call s:NetrwRestoreSetting(a:vt."netrw_slashkeep","@/")
                            
                            "  call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
                            "  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist"),'~'.expand("<slnum>"))
                            "  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "  call Decho("diff=".&l:diff." win#".winnr()." w:netrw_diffkeep=".(exists("w:netrw_diffkeep")? w:netrw_diffkeep : "doesn't exist"),'~'.expand("<slnum>"))
                            "  call Decho("ts=".&l:ts,'~'.expand("<slnum>"))
                              " Moved the filetype detect here from NetrwGetFile() because remote files
                              " were having their filetype detect-generated settings overwritten by
                              " NetrwOptionRestore.
                              if &ft != "netrw"
                            "   call Decho("before: filetype detect  (ft=".&ft.")",'~'.expand("<slnum>"))
                               filetype detect
                            "   call Decho("after : filetype detect  (ft=".&ft.")",'~'.expand("<slnum>"))
                              endif
                            "  call Decho("(s:NetrwOptionsRestore) lines=".&lines)
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwOptionsRestore : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)

FUNCTION  go#config#GoplsEnabled()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:576
Called 7 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    7              0.000016   return get(g:, 'go_gopls_enabled', 1)

FUNCTION  go#config#HighlightVariableDeclarations()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:481
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return get(g:, 'go_highlight_variable_declarations', 0)

FUNCTION  <SNR>67_StopPoller()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:590
Called 14 times
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
   14              0.000035   call timer_stop( a:poller.id )
   14              0.000027   let a:poller.id = -1

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim:218
Called 5 times
Total time:   0.163881
 Self time:   0.018542

count  total (s)   self (s)
    5              0.000016   let bufnr = a:0 ? a:1 : ''
    5              0.000018   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    5              0.000051   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    5              0.000014   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   12              0.000020   for mode in mapped
    7              0.000020     if mode == 'inactive' && winnr('$') == 1
                                  " there exist no inactive windows, don't need to create all those
                                  " highlighting groups
                                  continue
    7              0.000005     endif
    7              0.000034     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    4              0.000013       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  143              0.000261       for kvp in items(dict)
  139              0.000310         let mode_colors = kvp[1]
  139              0.000249         let name = kvp[0]
  139              0.000388         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
    1              0.000002           let name = 'airline_c'.bufnr
  139              0.000088         endif
  139   0.031465   0.001089         call airline#highlighter#exec(name.suffix, mode_colors)
                            
  417              0.000686         for accent in keys(s:accents)
  278              0.000671           if !has_key(p.accents, accent)
                                        continue
  278              0.000150           endif
  278              0.000841           let colors = copy(mode_colors)
  278              0.000722           if p.accents[accent][0] != ''
  139              0.000389             let colors[0] = p.accents[accent][0]
  278              0.000132           endif
  278              0.000576           if p.accents[accent][2] != ''
  139              0.000330             let colors[2] = p.accents[accent][2]
  278              0.000135           endif
  278              0.000496           if len(colors) >= 5
  278              0.000889             let colors[4] = get(p.accents[accent], 4, '')
                                      else
                                        call add(colors, get(p.accents[accent], 4, ''))
  278              0.000141           endif
  278   0.062524   0.002359           call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  417              0.000330         endfor
  143              0.000084       endfor
                            
                                  " TODO: optimize this
  112              0.000207       for sep in items(s:separators)
  108   0.056019   0.001221         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  112              0.000097       endfor
    7              0.000006     endif
   12              0.000015   endfor

FUNCTION  go#lsp#message#Format()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp/message.vim:61
Called 1 time
Total time:   0.000118
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000117   0.000019   return { 'notification': 0, 'method': 'textDocument/formatting', 'params': {   'textDocument': {       'uri': go#path#ToURI(a:file)   },   'options': {     'insertSpaces': v:false,   }, } }

FUNCTION  airline#builder#get_next_group()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim:49
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000001   let x = a:i + 1
    1              0.000002   let l = len(a:sections)
    2              0.000002   while x < l
    2              0.000006     let group = a:sections[x][0]
    2              0.000004     if group != '' && group != '|'
    1              0.000001       return group
    1              0.000001     endif
    1              0.000001     let x = x + 1
    1              0.000001   endwhile
                              return ''

FUNCTION  airline#parts#ffenc()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/parts.vim:105
Called 30 times
Total time:   0.000724
 Self time:   0.000724

count  total (s)   self (s)
   30              0.000113   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
   30              0.000060   let bomb     = &l:bomb ? '[BOM]' : ''
   30              0.000222   let ff       = strlen(&ff) ? '['.&ff.']' : ''
   30              0.000152   if expected is# &fenc.bomb.ff
                                return ''
   30              0.000016   else
   30              0.000097     return &fenc.bomb.ff
                              endif

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim:100
Called 30 times
Total time:   0.000636
 Self time:   0.000636

count  total (s)   self (s)
   30              0.000213   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  'gundo|undotree|vimfiler|tagbar|nerd_tree|startify')
   30              0.000398   return match(a:name, pat) > -1

FUNCTION  <SNR>100_await()
    Defined: ~/.vim/bundle/vim-go/autoload/go/promise.vim:37
Called 2 times
Total time:   0.104309
 Self time:   0.103071

count  total (s)   self (s)
    2              0.000017   let l:timer = timer_start(a:timeout, function('s:setretval', [a:default], self))
    4              0.000027   while !has_key(self, 'retval')
    2   0.104209   0.102971     sleep 50m
    4              0.000010   endwhile
    2              0.000014   call timer_stop(l:timer)
                            
    2              0.000008   if get(self, 'exception', 0)
                                throw self.retval
    2              0.000001   endif
    2              0.000006   return self.retval

FUNCTION  go#uri#EncodePath()
    Defined: ~/.vim/bundle/vim-go/autoload/go/uri.vim:9
Called 3 times
Total time:   0.000110
 Self time:   0.000059

count  total (s)   self (s)
    3              0.000006     let l:separator = '/'
    3   0.000028   0.000019     if go#util#IsWin()
                                  let l:separator = '\\'
    3              0.000001     endif
    3   0.000067   0.000025     return s:encode(a:value, '[^' . l:separator . 'A-Za-z0-9_.~-]')

FUNCTION  <SNR>67_AllowedToCompleteInBuffer()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:499
Called 144 times
Total time:   0.010356
 Self time:   0.008153

count  total (s)   self (s)
  144              0.001123   let buftype = getbufvar( a:buffer, '&buftype' )
                            
  144              0.000456   if has_key( s:buftype_blacklist, buftype )
   41              0.000033     return 0
  103              0.000124   endif
                            
  103              0.000405   let filetype = getbufvar( a:buffer, '&filetype' )
  103              0.000232   if empty( filetype )
                                let filetype = 'ycm_nofiletype'
  103              0.000058   endif
                            
  103              0.001242   let whitelist_allows = type( g:ycm_filetype_whitelist ) != v:t_dict || has_key( g:ycm_filetype_whitelist, '*' ) || s:HasAnyKey( g:ycm_filetype_whitelist, split( filetype, '\.' ) )
  103   0.003318   0.001666   let blacklist_allows = type( g:ycm_filetype_blacklist ) != v:t_dict || !s:HasAnyKey( g:ycm_filetype_blacklist, split( filetype, '\.' ) )
                            
  103              0.000238   let allowed = whitelist_allows && blacklist_allows
                            
  103   0.001368   0.000817   if !allowed || s:DisableOnLargeFile( a:buffer )
                                return 0
  103              0.000066   endif
                            
  103              0.000093   if allowed
  103              0.000399     let s:previous_allowed_buffer_number = bufnr( a:buffer )
  103              0.000060   endif
  103              0.000112   return allowed

FUNCTION  <SNR>61_exec_separator()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim:164
Called 142 times
Total time:   0.072038
 Self time:   0.005760

count  total (s)   self (s)
  142              0.000238   if pumvisible()
                                return
  142              0.000067   endif
  142   0.019182   0.001002   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  142   0.018801   0.000978   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  142              0.000403   let group = a:from.'_to_'.a:to.a:suffix
  142              0.000142   if a:inverse
   58              0.000286     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   84              0.000044   else
   84              0.000419     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  142              0.000070   endif
  142              0.000377   let a:dict[group] = colors
  142   0.031279   0.001004   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>67_OnFileSave()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:690
Called 1 time
Total time:   0.000408
 Self time:   0.000325

count  total (s)   self (s)
    1              0.000007   let buffer_number = str2nr( expand( '<abuf>' ) )
    1   0.000091   0.000008   if !s:AllowedToCompleteInBuffer( buffer_number )
                                return
    1              0.000001   endif
    1              0.000308   py3 ycm_state.OnFileSave( vimsupport.GetIntValue( 'buffer_number' ) )

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/parts.vim:63
Called 20 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
   20              0.000057   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  go#config#HighlightTrailingWhitespaceError()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:432
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return get(g:, 'go_highlight_trailing_whitespace_error', 0)

FUNCTION  airline#update_statusline()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline.vim:102
Called 1 time
Total time:   0.020360
 Self time:   0.000132

count  total (s)   self (s)
    1   0.000018   0.000013   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
    1              0.000001   endif
    3              0.000012   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
    2   0.000020   0.000013     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
    2              0.000001     endif
    2              0.000007     call setwinvar(nr, 'airline_active', 0)
    2              0.000012     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
    2   0.010003   0.000023     call s:invoke_funcrefs(context, s:inactive_funcrefs)
    3              0.000002   endfor
                            
    1              0.000003   unlet! w:airline_render_left w:airline_render_right
    1              0.000010   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
    1              0.000002   let w:airline_active = 1
    1              0.000006   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    1   0.010249   0.000013   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  go#package#InGOPATH()
    Defined: ~/.vim/bundle/vim-go/autoload/go/package.vim:139
Called 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000039   let l:dir = expand("%:p:h")
    1              0.000004   if has_key(s:in_gopath, dir)
    1              0.000007     return s:in_gopath[l:dir][0] !=#  '_'
                              endif
                            
                              try
                                " turn off module support so that `go list` will report the package name
                                " with a leading '_' when the current buffer is not within GOPATH.
                                let Restore_modules = go#util#SetEnv('GO111MODULE', 'off')
                                let [l:out, l:err] = go#util#ExecInDir(['go', 'list'])
                                if l:err != 0
                                  return 0
                                endif
                            
                                let l:importpath = split(l:out, '\n')[0]
                                if len(l:importpath) > 0
                                  let s:in_gopath[l:dir] = l:importpath
                                endif
                              finally
                                call call(Restore_modules, [])
                              endtry
                            
                              return len(l:importpath) > 0 && l:importpath[0] !=# '_'

FUNCTION  <SNR>61_get_syn()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim:25
Called 1768 times
Total time:   0.048534
 Self time:   0.048534

count  total (s)   self (s)
 1768              0.004235   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
 1768              0.000939   endif
 1768              0.002033   let color = ''
 1768              0.005634   if hlexists(a:group)
 1662              0.009541     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 1768              0.001013   endif
 1768              0.003857   if empty(color) || color == -1
                                " should always exists
  294              0.001921     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
  294              0.000527     if empty(color) || color == -1
  294              0.000329       let color = 'NONE'
  294              0.000156     endif
 1768              0.000845   endif
 1768              0.001675   return color

FUNCTION  go#util#GetLines()
    Defined: ~/.vim/bundle/vim-go/autoload/go/util.vim:449
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000018   let buf = getline(1, '$')
    1              0.000002   if &encoding != 'utf-8'
                                let buf = map(buf, 'iconv(v:val, &encoding, "utf-8")')
    1              0.000000   endif
    1              0.000001   if &l:fileformat == 'dos'
                                " XXX: line2byte() depend on 'fileformat' option.
                                " so if fileformat is 'dos', 'buf' must include '\r'.
                                let buf = map(buf, 'v:val."\r"')
    1              0.000001   endif
    1              0.000001   return buf

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/parts.vim:88
Called 30 times
Total time:   0.001267
 Self time:   0.000631

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files, 
                              " but not special ones like e.g. NERDTree)
   30   0.000920   0.000284   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
   30              0.000018   endif
   30              0.000076   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
   30              0.000014   else
   30              0.000057     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  <SNR>65_build_sections()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/default.vim:35
Called 4 times
Total time:   0.001119
 Self time:   0.000217

count  total (s)   self (s)
   22              0.000025   for key in a:keys
   18              0.000045     if (key == 'warning' || key == 'error') && !a:context.active
    4              0.000002       continue
   14              0.000006     endif
   14   0.000993   0.000091     call s:add_section(a:builder, a:context, key)
   18              0.000011   endfor

FUNCTION  <SNR>5_SynSet()
    Defined: /usr/local/Cellar/macvim/9.0.0065/MacVim.app/Contents/Resources/vim/runtime/syntax/synload.vim:33
Called 5 times
Total time:   0.003594
 Self time:   0.001022

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    5              0.000063   syn clear
    5              0.000016   if exists("b:current_syntax")
                                unlet b:current_syntax
    5              0.000004   endif
                            
    5              0.000021   0verbose let s = expand("<amatch>")
    5              0.000007   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    5              0.000005   elseif s == "OFF"
                                let s = ""
    5              0.000003   endif
                            
    5              0.000005   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
    2              0.000012     for name in split(s, '\.')
    1              0.000002       if !empty(name)
    1   0.003343   0.000771 	exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    1              0.000002       endif
    2              0.000002     endfor
    5              0.000002   endif

FUNCTION  go#config#ImportsAutosave()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:317
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    2              0.000004   return get(g:, 'go_imports_autosave', 1)

FUNCTION  airline#util#getwinvar()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim:55
Called 29 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
   29              0.000081     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim:91
Called 564 times
Total time:   0.122345
 Self time:   0.040293

count  total (s)   self (s)
  564              0.000879   if pumvisible()
                                return
  564              0.000300   endif
  564              0.000802   let colors = a:colors
  564              0.000614   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  564              0.000297   endif
  564   0.068760   0.004120   let old_hi = airline#highlighter#get_highlight(a:group)
  564              0.001054   if len(colors) == 4
  142              0.000347     call add(colors, '')
  564              0.000259   endif
  564              0.000722   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
  564              0.000307   else
  564              0.003844     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  564              0.000296   endif
  564   0.011541   0.003372   let colors = s:CheckDefined(colors)
  564   0.009444   0.003686   if old_hi != new_hi || !s:hl_group_exists(a:group)
   85   0.006203   0.002718     let cmd = printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg='), s:Get(colors, 1, 'guibg='), s:Get(colors, 2, 'ctermfg='), s:Get(colors, 3, 'ctermbg='), s:Get(colors, 4, 'gui='), s:Get(colors, 4, 'cterm='), s:Get(colors, 4, 'term='))
   85              0.000982     exe cmd
   85              0.000235     if has_key(s:hl_groups, a:group)
   85              0.000188       let s:hl_groups[a:group] = colors
   85              0.000051     endif
  564              0.000263   endif

FUNCTION  go#config#HighlightFunctionParameters()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:444
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
                              " fallback to highlight_function_arguments for backwards compatibility
    1              0.000005   return get(g:, 'go_highlight_function_parameters', get(g:, 'go_highlight_function_arguments', 0))

FUNCTION  <SNR>67_OnCursorMovedNormalMode()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:849
Called 2 times
Total time:   0.000337
 Self time:   0.000163

count  total (s)   self (s)
    2   0.000189   0.000015   if !s:AllowedToCompleteInCurrentBuffer()
                                return
    2              0.000000   endif
                            
    2              0.000142   py3 ycm_state.OnCursorMoved()

FUNCTION  go#lsp#message#CodeActionImports()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp/message.vim:76
Called 1 time
Total time:   0.000120
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000119   0.000012   return s:codeAction('source.organizeImports', a:file)

FUNCTION  go#config#HighlightArrayWhitespaceError()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:416
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004   return get(g:, 'go_highlight_array_whitespace_error', 0)

FUNCTION  go#lsp#Format()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:1509
Called 1 time
Total time:   0.053832
 Self time:   0.000125

count  total (s)   self (s)
    1              0.000022   let l:fname = expand('%:p')
                              " send the current file so that TextEdits will be relative to the current
                              " state of the buffer.
    1   0.000115   0.000008   call go#lsp#DidChange(l:fname)
                            
    1   0.000016   0.000006   let l:lsp = s:lspfactory.get()
                            
    1   0.000083   0.000009   let l:state = s:newHandlerState('')
    1   0.000034   0.000016   let l:handleFormat = go#promise#New(function('s:handleFormat', [], l:state), 10000, '')
    1              0.000004   let l:state.handleResult = l:handleFormat.wrapper
    1              0.000002   let l:state.error = l:handleFormat.wrapper
    1              0.000006   let l:state.handleError = function('s:handleFormatError', [l:fname], l:state)
    1   0.000127   0.000009   let l:msg = go#lsp#message#Format(l:fname)
    1   0.000251   0.000010   call l:lsp.sendMessage(l:msg, l:state)
                            
    1   0.000130   0.000016   call go#fmt#CleanErrors()
                            
                              " await the result to avoid any race conditions among autocmds (e.g.
                              " BufWritePre and BufWritePost)
    1   0.053037   0.000012   call l:handleFormat.await()

FUNCTION  <SNR>64_get_accented_line()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim:167
Called 23 times
Total time:   0.000873
 Self time:   0.000873

count  total (s)   self (s)
   23              0.000031   if a:self._context.active
   15              0.000020     let contents = []
   15              0.000096     let content_parts = split(a:contents, '__accent')
   29              0.000047     for cpart in content_parts
   14              0.000079       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   14              0.000033       call add(contents, cpart)
   29              0.000023     endfor
   15              0.000043     let line = join(contents, a:group)
   15              0.000082     let line = substitute(line, '__restore__', a:group, 'g')
    8              0.000007   else
    8              0.000075     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
    8              0.000045     let line = substitute(line, '%#__restore__#', '', 'g')
   23              0.000012   endif
   23              0.000024   return line

FUNCTION  <SNR>67_OnFileTypeSet()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:668
Called 1 time
Total time:   0.001885
 Self time:   0.000909

count  total (s)   self (s)
                              " The contents of the command-line window are empty when the filetype is set
                              " for the first time. Users should never change its filetype so we only rely
                              " on the CmdwinEnter event for that window.
    1              0.000003   if !empty( getcmdwintype() )
                                return
    1              0.000000   endif
                            
    1   0.000088   0.000006   if !s:AllowedToCompleteInCurrentBuffer()
                                return
    1              0.000001   endif
                            
    1   0.000032   0.000005   call s:SetUpCompleteopt()
    1   0.000009   0.000007   call s:EnableCompletingInCurrentBuffer()
    1   0.000016   0.000005   call s:StartMessagePoll()
    1   0.000097   0.000005   call s:EnableAutoHover()
                            
    1              0.000856   py3 ycm_state.OnFileTypeSet()
    1   0.000775   0.000013   call s:OnFileReadyToParse( 1 )

FUNCTION  go#config#AutoTypeInfo()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:345
Called 4 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    4              0.000011   return get(g:, "go_auto_type_info", 0)

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/parts.vim:67
Called 20 times
Total time:   0.000452
 Self time:   0.000452

count  total (s)   self (s)
   20              0.000187   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   20              0.000031   if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
   20              0.000012   endif
   20              0.000015   return ''

FUNCTION  go#config#ImportsMode()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:365
Called 2 times
Total time:   0.000021
 Self time:   0.000016

count  total (s)   self (s)
    2   0.000021   0.000016   return get(g:, "go_imports_mode", go#config#GoplsEnabled() ? 'gopls' : 'goimports')

FUNCTION  <SNR>64_get_transitioned_seperator()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim:143
Called 17 times
Total time:   0.018418
 Self time:   0.000704

count  total (s)   self (s)
   17              0.000020   let line = ''
   17   0.009187   0.000130   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   17              0.000084   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
   17              0.000011   else
   17   0.008790   0.000133     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   17              0.000068     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   17              0.000059     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   17              0.000039     let line .= '%#'.a:group.'#'
   17              0.000007   endif
   17              0.000018   return line

FUNCTION  youcompleteme#GetCommandResponseAsync()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1284
Called 4 times
Total time:   0.001614
 Self time:   0.001263

count  total (s)   self (s)
    4   0.000379   0.000028   if !s:AllowedToCompleteInCurrentBuffer()
                                eval a:callback( '' )
                                return
    4              0.000003   endif
                            
    4              0.000008   if !get( b:, 'ycm_completing' )
                                eval a:callback( '' )
                                return
    4              0.000001   endif
                            
    4              0.000006   if s:pollers.command.id != -1
                                eval a:callback( '' )
                                return
    4              0.000003   endif
                            
    4              0.001121   py3 ycm_state.SendCommandRequestAsync( vim.eval( "a:000" ) )
                            
    4              0.000054   let s:pollers.command.id = timer_start( s:pollers.command.wait_milliseconds, function( 's:PollCommand', [ 'StringResponse', a:callback ] ) )

FUNCTION  <SNR>69_get_separator_change_with_end()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/builder.vim:76
Called 4 times
Total time:   0.001379
 Self time:   0.000109

count  total (s)   self (s)
    4              0.000005   let sep_change = 0
    4              0.000009   if !empty(a:new_end_group) " Separator between title and the end
    3   0.000804   0.000026     let sep_change += airline#builder#should_change_group(a:new_group, a:new_end_group) ? a:sep_size : a:alt_sep_size
    4              0.000003   endif
    4              0.000008   if !empty(a:old_group) " Separator between the title and the one adjacent
    1   0.000256   0.000009     let sep_change += airline#builder#should_change_group(a:new_group, a:old_group) ? a:sep_size : a:alt_sep_size
    1              0.000001     if !empty(a:old_end_group) " Remove mis-predicted separator
    1   0.000256   0.000011       let sep_change -= airline#builder#should_change_group(a:old_group, a:old_end_group) ? a:sep_size : a:alt_sep_size
    1              0.000001     endif
    4              0.000000   endif
    4              0.000004   return sep_change

FUNCTION  <SNR>61_CheckDefined()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim:123
Called 564 times
Total time:   0.008169
 Self time:   0.008169

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  564              0.001547   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  564              0.000303   endif
  564              0.001453   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
  564              0.000640     return a:colors
                              endif
                            
                              for val in a:colors
                                if !empty(val) && val !=# 'NONE'
                                  return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/parts.vim:59
Called 20 times
Total time:   0.000109
 Self time:   0.000109

count  total (s)   self (s)
   20              0.000103   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim:35
Called 18 times
Total time:   0.000297
 Self time:   0.000297

count  total (s)   self (s)
   18              0.000061   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
   18              0.000098   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
   18              0.000068   if getbufvar(a:bufnr, '&modified') == 1
    2              0.000004     let _ .= s:buf_modified_symbol
   18              0.000009   endif
   18              0.000018   return _

FUNCTION  airline#extensions#tabline#formatters#default#format()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim:12
Called 18 times
Total time:   0.001938
 Self time:   0.001641

count  total (s)   self (s)
   18              0.000054   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
   18              0.000019   let _ = ''
                            
   18              0.000048   let name = bufname(a:bufnr)
   18              0.000027   if empty(name)
                                let _ .= '[No Name]'
   18              0.000011   else
   18              0.000018     if s:fnamecollapse
                                  " Does not handle non-ascii characters like Cyrillic: 'D/Учёба/t.c'
                                  "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
   18              0.000980       let _ .= pathshorten(fnamemodify(name, fmod))
                                else
                                  let _ .= fnamemodify(name, fmod)
   18              0.000010     endif
   18              0.000081     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
   18              0.000010     endif
   18              0.000010   endif
                            
   18   0.000481   0.000184   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim:47
Called 60 times
Total time:   0.000548
 Self time:   0.000548

count  total (s)   self (s)
   60              0.000172   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
   60              0.000030   endif
   60              0.000170   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/parts.vim:55
Called 20 times
Total time:   0.000496
 Self time:   0.000173

count  total (s)   self (s)
   20   0.000484   0.000161   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>64_get_seperator()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim:159
Called 13 times
Total time:   0.016377
 Self time:   0.000220

count  total (s)   self (s)
   13   0.003472   0.000100   if airline#builder#should_change_group(a:prev_group, a:group)
   12   0.012893   0.000108     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
    1              0.000000   else
    1              0.000003     return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  airline#extensions#tabline#buflist#invalidate()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/buflist.vim:6
Called 42 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
   42              0.000060   unlet! s:current_buffer_list

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/quickfix.vim:14
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000002   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
    1              0.000001   endif

FUNCTION  <SNR>46_is_excluded_window()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions.vim:90
Called 3 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
    3              0.000006   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
    3              0.000003   endfor
                            
   12              0.000011   for matchw in g:airline_exclude_filenames
    9              0.000048     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
    9              0.000006     endif
   12              0.000005   endfor
                            
    3              0.000003   if g:airline_exclude_preview && &previewwindow
                                return 1
    3              0.000002   endif
                            
    3              0.000003   return 0

FUNCTION  <SNR>69_evaluate_tabline()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/builder.vim:209
Called 6 times
Total time:   0.000567
 Self time:   0.000277

count  total (s)   self (s)
    6              0.000009   let tabline = a:tabline
    6   0.000361   0.000071   let tabline = substitute(tabline, '%{\([^}]\+\)}', '\=eval(submatch(1))', 'g')
    6              0.000045   let tabline = substitute(tabline, '%#[^#]\+#', '', 'g')
    6              0.000034   let tabline = substitute(tabline, '%(\([^)]\+\)%)', '\1', 'g')
    6              0.000025   let tabline = substitute(tabline, '%\d\+[TX]', '', 'g')
    6              0.000022   let tabline = substitute(tabline, '%=', '', 'g')
    6              0.000022   let tabline = substitute(tabline, '%\d*\*', '', 'g')
    6              0.000020   if has('tablineat')
                                let tabline = substitute(tabline, '%@[^@]\+@', '', 'g')
    6              0.000003   endif
    6              0.000006   return tabline

FUNCTION  airline#util#strchars()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim:92
Called 6 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    6              0.000014   if exists('*strchars')
    6              0.000013     return strchars(a:str)
                              else
                                return strlen(substitute(a:str, '.', 'a', 'g'))
                              endif

FUNCTION  <SNR>65_get_section()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/default.vim:20
Called 20 times
Total time:   0.000667
 Self time:   0.000607

count  total (s)   self (s)
   20              0.000049   if has_key(s:section_truncate_width, a:key)
   13              0.000037     if winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
   13              0.000009     endif
   20              0.000007   endif
   20              0.000032   let spc = g:airline_symbols.space
   20              0.000065   if !exists('g:airline_section_{a:key}')
                                return ''
   20              0.000009   endif
   20   0.000206   0.000146   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   20              0.000112   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   20              0.000062   return empty(text) ? '' : prefix.text.suffix

FUNCTION  <SNR>26_register()
    Defined: ~/.vim/bundle/vim-go/plugin/go.vim:243
Called 1 time
Total time:   0.000102
 Self time:   0.000096

count  total (s)   self (s)
    1              0.000005   if !(&modifiable && expand('<amatch>') ==# 'go')
                                return
    1              0.000000   endif
                            
                              " Resolve any symlinks in <afile> so that the filename will match what Vim
                              " will ultimately and usually produce.
    1   0.000093   0.000087   call go#lsp#DidOpen(resolve(expand('<afile>:p')))

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/wordcount.vim:34
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000015   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                call airline#extensions#prepend_to_section('z', '%{get(b:, "airline_wordcount", "")}')
    1              0.000001   endif

FUNCTION  <SNR>67_OnBufferUnload()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:716
Called 42 times
Total time:   0.001399
 Self time:   0.000988

count  total (s)   self (s)
                              " Expanding <abuf> returns the unloaded buffer number as a string but we want
                              " it as a true number for the getbufvar function.
   42              0.000185   let buffer_number = str2nr( expand( '<abuf>' ) )
   42   0.000696   0.000285   if !s:AllowedToCompleteInBuffer( buffer_number )
   41              0.000022     return
    1              0.000001   endif
                            
    1              0.000422   py3 ycm_state.OnBufferUnload( vimsupport.GetIntValue( 'buffer_number' ) )

FUNCTION  go#fmt#CleanErrors()
    Defined: ~/.vim/bundle/vim-go/autoload/go/fmt.vim:187
Called 2 times
Total time:   0.000182
 Self time:   0.000067

count  total (s)   self (s)
    2   0.000133   0.000018   let l:listtype = go#list#Type("GoFmt")
                            
                              " clean up previous list
    2              0.000004   if l:listtype == "quickfix"
                                let l:list_title = getqflist({'title': 1})
    2              0.000002   else
    2              0.000015     let l:list_title = getloclist(0, {'title': 1})
    2              0.000001   endif
                            
    2              0.000012   if has_key(l:list_title, 'title') && (l:list_title['title'] == 'Format' || l:list_title['title'] == 'GoMetaLinterAutoSave')
                                call go#list#Clean(l:listtype)
    2              0.000000   endif

FUNCTION  <SNR>67_ShouldUseSignatureHelp()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1113
Called 1 time
Total time:   0.000324
 Self time:   0.000324

count  total (s)   self (s)
    1              0.000324   return py3eval( 'vimsupport.VimSupportsPopupWindows()' )

FUNCTION  <SNR>19_LoadFTPlugin()
    Defined: /usr/local/Cellar/macvim/9.0.0065/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim:22
Called 1 time
Total time:   0.030756
 Self time:   0.007266

count  total (s)   self (s)
    1              0.000003   if exists("b:undo_ftplugin")
                                # We assume b:undo_ftplugin is using legacy script syntax
    1              0.000104     legacy exe b:undo_ftplugin
    1              0.000002     unlet! b:undo_ftplugin b:did_ftplugin
    1              0.000000   endif
                            
    1              0.000001   var s = expand("<amatch>")
    1              0.000000   if s != ""
    1              0.000006     if &cpo =~# "S" && exists("b:did_ftplugin")
                                  # In compatible mode options are reset to the global values, need to
                                  # set the local values also when a plugin was already used.
                                  unlet b:did_ftplugin
                                endif
                            
                                # When there is a dot it is used to separate filetype names.  Thus for
                                # "aaa.bbb" load "aaa" and then "bbb".
    1              0.000003     for name in split(s, '\.')
    1   0.030574   0.007084       exe 'runtime! ftplugin/' .. name .. '.vim ftplugin/' .. name .. '_*.vim ftplugin/' .. name .. '/*.vim'
    1              0.000002     endfor
    1              0.000000   endif

FUNCTION  polyglot#init#is_disabled()
    Defined: ~/.vim/bundle/vim-polyglot/autoload/polyglot/init.vim:23
Called 3 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
    3              0.000007   if !g:polyglot_initialized
    3              0.000017     if a:path[0:7] == "autoload"
                                  let g:polyglot_initialized = 1
                            
                                  for p in globpath(&rtp, a:path, 0, 1)
                                    if p != a:caller
                                      exe "source " . p
                                      return 1
                                    endif
                                  endfor
    3              0.000002     endif
    3              0.000003   endif
                            
    3              0.000011   return has_key(g:polyglot_is_disabled, a:name)

FUNCTION  airline#extensions#tabline#builder#new()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/builder.vim:227
Called 1 time
Total time:   0.000037
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000029   0.000006   let builder = airline#builder#new(a:context)
    1              0.000002   let builder._build = builder.build
    1              0.000004   call extend(builder, s:prototype, 'force')
    1              0.000000   return builder

FUNCTION  airline#statusline()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline.vim:137
Called 30 times
Total time:   0.000425
 Self time:   0.000425

count  total (s)   self (s)
   30              0.000200   if has_key(s:contexts, a:winnr)
   30              0.000186     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  go#config#HighlightStringSpellcheck()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:465
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return get(g:, 'go_highlight_string_spellcheck', 1)

FUNCTION  go#config#MetalinterAutosave()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:301
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000003   return get(g:, "go_metalinter_autosave", 0)

FUNCTION  <SNR>61_Get()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim:155
Called 595 times
Total time:   0.003485
 Self time:   0.003485

count  total (s)   self (s)
  595              0.001462   let res=get(a:dict, a:key, '')
  595              0.000634   if res is ''
  307              0.000231     return ''
  288              0.000145   else
  288              0.000423     return a:prefix. res
                              endif

FUNCTION  <SNR>69_tabline_evaluated_length()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/builder.vim:223
Called 6 times
Total time:   0.000666
 Self time:   0.000071

count  total (s)   self (s)
    6   0.000661   0.000066   return airline#util#strchars(s:evaluate_tabline(a:tabline))

FUNCTION  airline#extensions#apply()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions.vim:59
Called 3 times
Total time:   0.000255
 Self time:   0.000130

count  total (s)   self (s)
                            
    3   0.000149   0.000024   if s:is_excluded_window()
                                return -1
    3              0.000002   endif
                            
    3              0.000005   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
    3              0.000002   endif
                            
    3              0.000003   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
    3              0.000001   endif
                            
    3              0.000015   if has_key(s:filetype_overrides, &ft)
                                let args = s:filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
    3              0.000002   endif
                            
    3              0.000009   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
    3              0.000002   endfor

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim:130
Called 18 times
Total time:   0.004642
 Self time:   0.000473

count  total (s)   self (s)
   18              0.000032   if a:group1 == a:group2
                                return 0
   18              0.000012   endif
   18   0.002255   0.000123   let color1 = airline#highlighter#get_highlight(a:group1)
   18   0.002168   0.000131   let color2 = airline#highlighter#get_highlight(a:group2)
   18              0.000024   if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
   18              0.000012   else
   18              0.000064     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim:55
Called 884 times
Total time:   0.102240
 Self time:   0.046263

count  total (s)   self (s)
  884              0.003305   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                return s:hl_groups[a:group]
  884              0.000499   else
  884   0.029736   0.005077     let fg = s:get_syn(a:group, 'fg')
  884   0.028780   0.004905     let bg = s:get_syn(a:group, 'bg')
  884              0.011106     let reverse = g:airline_gui_mode ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  884              0.004035     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  884              0.001115     let opts = a:000
  884              0.000818     if bold
  139              0.000198       let opts = ['bold']
  884              0.000492     endif
  884   0.014635   0.007192     let res = reverse ? s:get_array(bg, fg, opts) : s:get_array(fg, bg, opts)
  884              0.000549   endif
  884              0.002685   let s:hl_groups[a:group] = res
  884              0.000794   return res

FUNCTION  <SNR>93_requestComplete()
    Defined: ~/.vim/bundle/vim-go/autoload/go/lsp.vim:546
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000004   if self.statustype == ''
    2              0.000002     return
                              endif
                            
                              if go#config#EchoCommandInfo()
                                " redraw to avoid messages piling up
                                redraw
                                let prefix = '[' . self.statustype . '] '
                                if a:ok
                                  call go#util#EchoSuccess(prefix . "SUCCESS")
                                else
                                  call go#util#EchoError(prefix . "FAIL")
                                endif
                              endif
                            
                              let status = { 'desc': 'last status', 'type': self.statustype, 'state': "success", }
                            
                              if !a:ok
                                let status.state = "failed"
                              endif
                            
                              if has_key(self, 'started_at')
                                let elapsed_time = reltimestr(reltime(self.started_at))
                                " strip whitespace
                                let elapsed_time = substitute(elapsed_time, '^\s*\(.\{-}\)\s*$', '\1', '')
                                let status.state .= printf(" (%ss)", elapsed_time)
                              endif
                            
                              call go#statusline#Update(self.jobdir, status)

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim:12
Called 40 times
Total time:   0.000677
 Self time:   0.000677

count  total (s)   self (s)
   40              0.000248   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
   40              0.000020   else
   40              0.000042     return a:text
                              endif

FUNCTION  <SNR>67_PollCommand()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1332
Called 4 times
Total time:   0.001975
 Self time:   0.001062

count  total (s)   self (s)
    4              0.000213   if py3eval( 'ycm_state.GetCommandRequest() is None' )
                                " Possible in case of race conditions and things like RestartServer
                                " But particualrly in the tests
                                return
    4              0.000004   endif
                            
    4              0.000105   if !py3eval( 'ycm_state.GetCommandRequest().Done()' )
                                let s:pollers.command.id = timer_start( s:pollers.command.wait_milliseconds, function( 's:PollCommand', [ a:response_func, a:callback ] ) )
                                return
    4              0.000002   endif
                            
    4   0.000068   0.000042   call s:StopPoller( s:pollers.command )
                            
    4              0.000597   let result = py3eval( 'ycm_state.GetCommandRequest().' .a:response_func . '()' )
                            
    4   0.000927   0.000040   eval a:callback( result )

FUNCTION  <SNR>72_NetrwEnew()
    Defined: /usr/local/Cellar/macvim/9.0.0065/MacVim.app/Contents/Resources/vim/runtime/autoload/netrw.vim:11985
Called 1 time
Total time:   0.061744
 Self time:   0.000300

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwEnew() a:0=".a:0." win#".winnr()." winnr($)=".winnr("$")." bufnr($)=".bufnr("$")." expand(%)<".expand("%").">")
                            "  call Decho("curdir<".((a:0>0)? a:1 : "")."> buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
                            
                              " Clean out the last buffer: 
                              " Check if the last buffer has # > 1, is unlisted, is unnamed, and does not appear in a window
                              " If so, delete it.
    1   0.000030   0.000008   call s:NetrwBufRemover(bufnr("$"))
                            
                              " grab a function-local-variable copy of buffer variables
                            "  call Decho("make function-local copy of netrw variables",'~'.expand("<slnum>"))
    1              0.000005   if exists("b:netrw_bannercnt")      |let netrw_bannercnt       = b:netrw_bannercnt      |endif
    1              0.000004   if exists("b:netrw_browser_active") |let netrw_browser_active  = b:netrw_browser_active |endif
    1              0.000003   if exists("b:netrw_cpf")            |let netrw_cpf             = b:netrw_cpf            |endif
    1              0.000005   if exists("b:netrw_curdir")         |let netrw_curdir          = b:netrw_curdir         |endif
    1              0.000003   if exists("b:netrw_explore_bufnr")  |let netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
    1              0.000003   if exists("b:netrw_explore_indx")   |let netrw_explore_indx    = b:netrw_explore_indx   |endif
    1              0.000003   if exists("b:netrw_explore_line")   |let netrw_explore_line    = b:netrw_explore_line   |endif
    1              0.000003   if exists("b:netrw_explore_list")   |let netrw_explore_list    = b:netrw_explore_list   |endif
    1              0.000003   if exists("b:netrw_explore_listlen")|let netrw_explore_listlen = b:netrw_explore_listlen|endif
    1              0.000003   if exists("b:netrw_explore_mtchcnt")|let netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
    1              0.000004   if exists("b:netrw_fname")          |let netrw_fname           = b:netrw_fname          |endif
    1              0.000003   if exists("b:netrw_lastfile")       |let netrw_lastfile        = b:netrw_lastfile       |endif
    1              0.000003   if exists("b:netrw_liststyle")      |let netrw_liststyle       = b:netrw_liststyle      |endif
    1              0.000003   if exists("b:netrw_method")         |let netrw_method          = b:netrw_method         |endif
    1              0.000003   if exists("b:netrw_option")         |let netrw_option          = b:netrw_option         |endif
    1              0.000003   if exists("b:netrw_prvdir")         |let netrw_prvdir          = b:netrw_prvdir         |endif
                            
    1   0.060321   0.000018   NetrwKeepj call s:NetrwOptionsRestore("w:")
                            "  call Decho("generate a buffer with NetrwKeepj keepalt enew!",'~'.expand("<slnum>"))
                              " when tree listing uses file TreeListing... a new buffer is made.
                              " Want the old buffer to be unlisted.
                              " COMBAK: this causes a problem, see P43
                            "  setl nobl
    1              0.000003   let netrw_keepdiff= &l:diff
    1              0.000081   noswapfile NetrwKeepj keepalt enew!
    1              0.000006   let &l:diff= netrw_keepdiff
                            "  call Decho("bufnr($)=".bufnr("$")."<".bufname(bufnr("$"))."> winnr($)=".winnr("$"),'~'.expand("<slnum>"))
    1   0.001136   0.000017   NetrwKeepj call s:NetrwOptionsSave("w:")
                            
                              " copy function-local-variables to buffer variable equivalents
                            "  call Decho("copy function-local variables back to buffer netrw variables",'~'.expand("<slnum>"))
    1              0.000007   if exists("netrw_bannercnt")      |let b:netrw_bannercnt       = netrw_bannercnt      |endif
    1              0.000004   if exists("netrw_browser_active") |let b:netrw_browser_active  = netrw_browser_active |endif
    1              0.000003   if exists("netrw_cpf")            |let b:netrw_cpf             = netrw_cpf            |endif
    1              0.000005   if exists("netrw_curdir")         |let b:netrw_curdir          = netrw_curdir         |endif
    1              0.000003   if exists("netrw_explore_bufnr")  |let b:netrw_explore_bufnr   = netrw_explore_bufnr  |endif
    1              0.000003   if exists("netrw_explore_indx")   |let b:netrw_explore_indx    = netrw_explore_indx   |endif
    1              0.000003   if exists("netrw_explore_line")   |let b:netrw_explore_line    = netrw_explore_line   |endif
    1              0.000003   if exists("netrw_explore_list")   |let b:netrw_explore_list    = netrw_explore_list   |endif
    1              0.000003   if exists("netrw_explore_listlen")|let b:netrw_explore_listlen = netrw_explore_listlen|endif
    1              0.000003   if exists("netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt = netrw_explore_mtchcnt|endif
    1              0.000003   if exists("netrw_fname")          |let b:netrw_fname           = netrw_fname          |endif
    1              0.000003   if exists("netrw_lastfile")       |let b:netrw_lastfile        = netrw_lastfile       |endif
    1              0.000004   if exists("netrw_liststyle")      |let b:netrw_liststyle       = netrw_liststyle      |endif
    1              0.000003   if exists("netrw_method")         |let b:netrw_method          = netrw_method         |endif
    1              0.000003   if exists("netrw_option")         |let b:netrw_option          = netrw_option         |endif
    1              0.000003   if exists("netrw_prvdir")         |let b:netrw_prvdir          = netrw_prvdir         |endif
                            
    1              0.000002   if a:0 > 0
                               let b:netrw_curdir= a:1
                               if b:netrw_curdir =~ '/$'
                                if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                                 setl nobl
                                 file NetrwTreeListing
                                 setl nobl bt=nowrite bh=hide
                                 nno <silent> <buffer> [	:sil call <SID>TreeListMove('[')<cr>
                                 nno <silent> <buffer> ]	:sil call <SID>TreeListMove(']')<cr>
                                else
                                 call s:NetrwBufRename(b:netrw_curdir)
                                endif
                               endif
    1              0.000001   endif
    1              0.000010   if v:version >= 700 && has("balloon_eval") && !exists("s:initbeval") && !exists("g:netrw_nobeval") && has("syntax") && exists("g:syntax_on")
    1              0.000010    let &l:bexpr = "netrw#BalloonHelp()"
    1              0.000000   endif
                            
                            "  call Dret("s:NetrwEnew : buf#".bufnr("%")."<".bufname("%")."> expand(%)<".expand("%")."> expand(#)<".expand("#")."> bh=".&bh." win#".winnr()." winnr($)#".winnr("$"))

FUNCTION  <SNR>67_ShowHoverResult()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1451
Called 4 times
Total time:   0.000887
 Self time:   0.000654

count  total (s)   self (s)
    4              0.000026     call popup_hide( s:cursorhold_popup )
                            
    4              0.000010     if empty( a:response )
                                  return
    4              0.000002     endif
                            
                                " Try to position the popup at the cursor, but avoid wrapping. If the
                                " longest line is > screen width (&columns), then we just have to wrap, and
                                " place the popup at the leftmost column.
                                "
                                " Find the longest line (FIXME: probably doesn't work well for multi-byte)
    4              0.000026     let lines = split( a:response, "\n" )
    4              0.000031     let len = max( map( copy( lines ), "len( v:val )" ) )
                            
    4              0.000007     let wrap = 0
    4              0.000004     let col = 'cursor'
                            
                                " max width is screen columns minus x padding (2)
    4              0.000011     if len >= (&columns - 2)
                                  " There's at least one line > our max - enable word wrap and draw the
                                  " popup at the leftmost column
                                  let col = 1
                                  let wrap = 1
    4              0.000003     endif
                            
    4              0.000361     let s:cursorhold_popup = popup_atcursor(   lines,   {     'col': col,     'wrap': wrap,     'padding': [ 0, 1, 0, 1 ],     'moved': 'word',     'maxwidth': &columns,     'close': 'click',     'fixed': 0,   } )
    4   0.000365   0.000132     call setbufvar( winbufnr( s:cursorhold_popup ), '&syntax', b:ycm_hover.syntax )

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim:204
Called 5 times
Total time:   0.001690
 Self time:   0.000161

count  total (s)   self (s)
    5              0.000019   if getbufvar(a:bufnr, '&modified')
    2              0.000018     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    3              0.000003   else
    3              0.000023     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    5              0.000002   endif
                            
    5              0.000008   if !empty(colors)
    5   0.001583   0.000054     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    5              0.000003   endif

FUNCTION  go#config#HighlightOperators()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:436
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return get(g:, 'go_highlight_operators', 0)

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 20 times
Total time:   0.000211
 Self time:   0.000211

count  total (s)   self (s)
   20              0.000104   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   20              0.000095     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  <SNR>22_init()
    Defined: ~/.vim/bundle/vim-airline/plugin/airline.vim:12
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   if s:airline_initialized
    1              0.000001     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  echom 'Could not resolve airline theme "' . g:airline_theme . '". Themes have been migrated to github.com/vim-airline/vim-airline-themes.'
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              silent doautocmd User AirlineAfterInit

FUNCTION  go#config#HighlightChanWhitespaceError()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:420
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return get(g:, 'go_highlight_chan_whitespace_error', 0)

FUNCTION  go#config#HighlightDebug()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:493
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004   return get(g:, 'go_highlight_debug', 1)

FUNCTION  go#config#HighlightFields()
    Defined: ~/.vim/bundle/vim-go/autoload/go/config.vim:453
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return get(g:, 'go_highlight_fields', 0)

FUNCTION  <SNR>69_get_separator_change()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/builder.vim:68
Called 3 times
Total time:   0.000612
 Self time:   0.000029

count  total (s)   self (s)
    3   0.000610   0.000027   return s:get_separator_change_with_end(a:new_group, a:old_group, a:end_group, a:end_group, a:sep_size, a:alt_sep_size)

FUNCTION  <SNR>65_add_section()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/default.vim:47
Called 14 times
Total time:   0.000902
 Self time:   0.000358

count  total (s)   self (s)
   14              0.000061     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   14   0.000132   0.000069     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
    1              0.000001       return
   13              0.000005     endif
   13              0.000011     if condition
                                  call a:builder.add_raw('%(')
   13              0.000007     endif
   13   0.000589   0.000108     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   13              0.000012     if condition
                                  call a:builder.add_raw('%)')
   13              0.000007     endif

FUNCTION  go#util#IsWin()
    Defined: ~/.vim/bundle/vim-go/autoload/go/util.vim:40
Called 9 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    9              0.000024   return has('win32')

FUNCTION  <SNR>67_AllowedToCompleteInCurrentBuffer()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:530
Called 101 times
Total time:   0.011057
 Self time:   0.001195

count  total (s)   self (s)
  101   0.010992   0.001130   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  airline#builder#new()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim:231
Called 4 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
    4              0.000021   let builder = copy(s:prototype)
    4              0.000007   let builder._context = a:context
    4              0.000005   let builder._sections = []
                            
    4              0.000039   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    4              0.000004   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   30   0.167982   0.002411  airline#check_mode()
    5   0.163881   0.018542  airline#highlighter#highlight()
  564   0.122345   0.040293  airline#highlighter#exec()
    1   0.106032   0.000174  go#auto#fmt_autosave()
    2   0.105819   0.000085  go#fmt#Format()
    2   0.104309   0.103071  <SNR>100_await()
  884   0.102240   0.046263  airline#highlighter#get_highlight()
    1   0.080215   0.018315  <SNR>72_NetrwBookHistSave()
  142   0.072038   0.005760  <SNR>61_exec_separator()
    1   0.061744   0.000300  <SNR>72_NetrwEnew()
    1   0.060303   0.000020  <SNR>72_NetrwOptionsRestore()
    1   0.053832   0.000125  go#lsp#Format()
    1   0.051866   0.000128  go#lsp#Imports()
 1768   0.048534             <SNR>61_get_syn()
  284   0.036003   0.002572  airline#themes#get_highlight()
    1   0.030756   0.007266  <SNR>19_LoadFTPlugin()
    5   0.026093   0.002652  12()
   94   0.025568   0.015118  <SNR>67_ReceiveMessages()
   43   0.021782   0.001419  <SNR>22_on_window_changed()
    1   0.020360   0.000132  airline#update_statusline()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    2   0.104309   0.103071  <SNR>100_await()
 1768              0.048534  <SNR>61_get_syn()
  884   0.102240   0.046263  airline#highlighter#get_highlight()
  564   0.122345   0.040293  airline#highlighter#exec()
    5   0.163881   0.018542  airline#highlighter#highlight()
    1   0.080215   0.018315  <SNR>72_NetrwBookHistSave()
   94   0.025568   0.015118  <SNR>67_ReceiveMessages()
  564              0.008169  <SNR>61_CheckDefined()
  144   0.010356   0.008153  <SNR>67_AllowedToCompleteInBuffer()
  884              0.007443  <SNR>61_get_array()
    1   0.030756   0.007266  <SNR>19_LoadFTPlugin()
  142   0.072038   0.005760  <SNR>61_exec_separator()
  515              0.005758  <SNR>61_hl_group_exists()
    1   0.004702   0.004671  <SNR>67_OnVimLeave()
  595              0.003485  <SNR>61_Get()
    5   0.026093   0.002652  12()
  284   0.036003   0.002572  airline#themes#get_highlight()
   30   0.167982   0.002411  airline#check_mode()
   20   0.002975   0.002327  airline#extensions#whitespace#check()
   19   0.001743   0.001702  airline#extensions#tabline#buflist#list()

